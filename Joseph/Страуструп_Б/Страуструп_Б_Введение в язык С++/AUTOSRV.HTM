<html><head>
<title>Создание серверов автоматизации с помощью  C++Builder</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<p>&nbsp;
<center>
<h3>Создание серверов автоматизации с помощью  C++Builder</h3>
Наталия Елманова
</center>
<h4>Что такое  автоматизация </h4>
<p align="justify">Подавляющее большинство современных настольных приложений предназначено для выполнения пользователями тех или иных операций - создания документов, проведения расчетов, анализа данных и т.д.  В процессе выполнения подобного рода работ применяются различные внутренние сервисы этих приложений, например, вычисление значений по формулам, автоматическая нумерация абзацев, заголовков или страниц, проверка орфографии и многое другое. Нередко подобные приложения обладают встроенными макроязыками, позволяющими создать код, использующий эти сервисы, например, в случае часто повторяющихся последовательностей операций. Иначе говоря, приложения подобного рода.обладают программируемостью.
<p align="justify">Отметим, однако, что программирование с помощью макроязыков имеет свои недостатки, так как не существует спецификаций, которым должны подчиняться макроязыки. Соответственно в общем случае у каждого программируемого приложения имеется свой  макроязык, отличный от макроязыков других программируемых приложений <i>(Отличием здесь являются продукты фирмы Microsoft, где в качестве макроязыка выбрано подмножество Visual Basic - Visual Basic for Applications. Прим. ред)</i>.
<p align="justify">Более удобной реализацией программируемости настольных приложений  было бы наличие в них возможности предоставлять свои сервисы другим приложениям с помощью универсального механизма, не зависящего от встроенных макроязыков и позволяющего, в частности, использовать обычные языки программирования. Именно для этой цели и предназначен механизм, называемый автоматизацией (Automation) <i>(Ранее этот механизм назывался OLE Automation. Прим. ред)</i>. В этом случае приложение, предоставляющее тот или иной сервис, использует для этой цели интерфейсы содержащихся внутри его адресного пространства COM-объектов, и называется сервером автоматизации. Приложение, использующее сервис, называется контроллером автоматизации и может быть написано с помощью подавляющего большинства современных средств разработки. Отметим, что серверами автоматизации являются, в частности, такие популярные приложения, как Microsoft Office (Word, Excel, PowerPoint), Seagate Crystal Reports, Microsoft Internet Explorer и даже сама оболочка Windows 95/98/NT.
<p align="justify">В общем случае клиент и сервер находятся в разных адресных пространствах, и, соответственно, для управления сервером клиент должен обращаться к методам объектов, находящихся в другом адресном пространстве. Для этой цели используется технология LRPC (Local Remote Procedure Calls - локальные вызовы удаленных процедур).
<p align="justify">Каждый  COM-сервер (каковым является сервер автоматизации) и каждый класс COM-объектов обладает уникальным 128-битовым идентификатором GIUD (Global Unique Identifier). При обращении к классам COM-объектов  он иногда  называется CLSID (идентификатор класса). При создании COM-серверов (в том числе и серверов автоматизации)  с помощью  C++Builder GUID и CLSID генерируются автоматически, хотя при необходимости можно сгенерировать их с помощью вызова стандартной функции Windows API CoCreateGUID. Информация обо всех COM-серверах и классах COM-объектов хранится в системном реестре, что позволяет клиенту "не знать", в каком каталоге (или на каком компьютере локальной сети) находится COM-сервер.
<p align="justify">В общем случае COM-сервер представляет собой приложение, которое создает COM-объект и делает его доступным для других программ. .Сервер автоматизации   предоставляет для доступа объект специального типа - dispatch object. При этом в адресном пространстве приложения-контроллера, управляющего сервером, присутствует вариантная переменная, содержащая интерфейс <tt>IDispatch</tt>, открывающий предоставляющий доступ к этому объекту на COM-сервере..
<p align="justify">Контроллер может управлять сервером, например, инициируя его выполнение, создание с его помощью документов и иных объектов, изменение размеров, положения и видимости окна сервера, копирование объектов сервера в буфер обмена, добавление данных в созданный сервером документ, и т.д.. Наличие тех или иных возможностей управления сервером зависит от того, какие объекты, свойства и методы сервера предоставлены разработчиками сервера  для автоматизации с помощью внешних приложений.
<p align="justify">Подготовительный этап: создание приложения, подлежащего автоматизации
<p align="justify">Для создания сервера автоматизации следует создать обычное приложение и затем добавить к нему подобный объектописание класса COM-объектов, создаваемых этим приложением,  для осуществления доступа к функциональности, которую нужно автоматизировать.
<p align="justify">Разработаем простейший сервер автоматизации. С этой целью создадим обычное приложение, например, текстовый редактор, содержащий инструментальную панель с четырьмя кнопками и компонент TMemo, а также диалоговые панели открытия и сохранения файла.
<center>
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV1.GIF" width=323 height=233 border=0 alt="Главная форма будущего сервера автоматизации">
<p><i>Рис. 1. Главная форма будущего сервера автоматизации</i>
</center>
<p align="justify">Создадим обработчики событий, связанные с нажатием на кнопки,  и характерные для текстовых редакторов:
<p>
<pre>
//--------------------------------------------------------------
#include &lt;vcl.h&gt;
#pragma hdrstop
#include "main1.h"
//--------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
//--------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
    : TForm(Owner)
{
}
//--------------------------------------------------------------
void __fastcall TForm1::SpeedButton1Click(TObject *Sender)
{
Memo1->Lines->Clear();
}
//--------------------------------------------------------------
void __fastcall TForm1::SpeedButton2Click(TObject *Sender)
{
if (OpenDialog1->Execute())
 Memo1->Lines->LoadFromFile(OpenDialog1->FileName);
}
//--------------------------------------------------------------
void __fastcall TForm1::SpeedButton3Click(TObject *Sender)
{
if (SaveDialog1->Execute())  
 Memo1->Lines->SaveToFile(SaveDialog1->FileName);
}
//--------------------------------------------------------------
void __fastcall TForm1::SpeedButton4Click(TObject *Sender)
{
Close();
}
//--------------------------------------------------------------
</pre>
<p align="justify">Сохраним проект. Отметим, что пока созданный нами текстовый редактор представляет собой обычное Windows-приложение и не является сервером  автоматизации.
<h4>Превращение приложения в сервер автоматизации</h4>
<p align="justify">Для превращения созданного нами выше приложения в сервер автоматизации выберем элемент Automation Object со страницы ActiveX репозитария объектов: 
<center>
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV2.GIF" width=441 height=340 border=0 alt=" ">
<p><i>Рис. 2. Выбор Automation Object из репозитария объектов</i>
</center>
<p align="justify">Введем имя класса, под которым данный класс COM-объектов будет зарегистрирован в реестре.
<center>
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV3.GIF" width=375 height=126 border=0 alt="Диалоговая панель ввода имени класса">
<p><i>Рис. 3. Диалоговая панель ввода имени класса</i> 
</center>
<p align="justify">После этого мы окажемся в редакторе библиотеки типов (Type Library Editor),  в котором нам предстоит определить свойства и методы созданного класса COM-объектов.
<center> 
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV4.GIF" width=626 height=377 border=0 alt="Библиотека типов вновь созданного сервера">
<p><i>Рис. 4. Библиотека типов вновь созданного сервера</i>
</center>
<h4>Библиотека типов</h4>
<p align="justify">Что представляет собой библиотека типов и зачем она нужна? По существу, библиотека типов представляет собой двоичный файл с описанием интерфейсов COM-объекта и их методов. 
<p align="justify">Обычно такие описания создаются с помощью специального языка IDL (Interface Definition Language) и используются для того, чтобы разработчики знали, как создать код, реализующий методы COM-объекта (или вообще методы объекта, расположенного за пределами адресного пространства разрабатываемого приложения, так как IDL используется не только в COM-технологии, но и в иных технологиях, реализующих  вызовы удаленных процедур или функций, например, CORBA). Помимо этого, описания методов на языке IDL могут быть использованы для автоматической генерации  серверного и клиентского кода (так называемого proxy-кода и stub-кода) с помощью соответствующих утилит.
<p align="justify">С другой стороны, proxy-код и stub-код могут быть сгенерированы динамически. В этом случае клиент  должен динамически получать информацию о свойствах и методах интерфейсов COM-объекта, и в этом случае наличие библиотеки типов, содержащей такую информацию, может быть весьма удобно. Отметим, что библиотеку типов можно в принципе сгенерировать на основе описания на языке IDL с помощью специального компилятора MIDL, но в данном случае в этом нет необходимости. 
<p align="justify">Итак, приступим к редактированию библиотеки типов. Предположим, что мы хотим автоматизировать загрузку файла в окно редактора, сохранение набранного текста, очистку окна редактирования, определение и изменение ширины и видимости окна. Создадим также метод, добавляющий  строку к редактируемому тексту. С этой целью реализуемjопишем для нашего сервера методы FileNew, FileOpen, FileSave, AddLine и их параметры, а также свойства Width и Visible, и опишем их параметры. 
<p align="justify">Отметим, что типы данных, используемые для описания параметров методов, не совпадают с типами данных С++, так как в этом случае используются типы данных, принятые в IDL. Наиболее часто используемые типы данных языка IDL приведены в таблице 1.
Таблица 1. Наиболее часто используемые типы данных языка IDL
<p>
<center>
<table border=1>
<tr><th>Тип данных</th><th>Описание</th></tr>
<tr><td>short</td><td>Двухбайтовое целое число со знаком</td></tr>
<tr><td>long</td><td>Четырехбайтовое целое число со знаком</td></tr>
<tr><td>single</td><td>Четырехбайтовое действительное число</td></tr>
<tr><td>double</td><td>Восьмибайтовое действительное число</td></tr>
<tr><td>BSTR</td><td>Двоичная строка</td></tr>
<tr><td>DATE</td><td>Дата</td></tr>
<tr><td>VARIANT_BOOL</td><td>true= -1, false = 0</td></tr>
<tr><td>VARIANT</td><td>Указатель на вариантную переменную</td></tr>
<tr><td>int</td><td>Целое (размер в байтах в общем случае зависит от разрядности операционной системы)</td></tr>
</table>
</center>
<p align="justify">Подробный список  типов данных IDL можно найти в документации С++Builder.
<p align="justify">Отметим также, что наряду с типами данных IDL можно использовать все типы данных, определенные в самой библиотеке типов. а также в других библиотеках, на которые она ссылается.
<p align="justify">Метод FileNew параметров не имеет. Методы FileOpen и FileSave имеют один строковый параметр  типа BSTR  - имя файла. Метод Addline также имеет один строковый параметр, задающий добавляемую строку. Свойство Visible имеет логический тип  VARIANT_BOOL, при этом оно может быть как прочитано, так и изменено.  Свойство Width имеет целый тип  int (число пикселов) и также доступно как для чтения, так и для записи.
<p align="justify">В результате библиотека типов приобретет примерно следующий вид:
<center>
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV5.GIF" width=506 height=352 border=0 alt="Библиотека типов сервера автоматизации после описания свойств и методов объекта IDispatch"> 
<p><i>Рис. 5. Библиотека типов сервера автоматизации после описания свойств и методов объекта IDispatch</i>
</center>
<h4>Создание кода реализации методов объекта автоматизации</h4>
<p align="justify">Итак, мы описали свойства и методы нашего объекта, и теперь должны приступить к их реализации. Для этой цели следует нажать кнопку Refresh на инструментальной панели редактора библиотеки типов.  После этого будет сгенерирован еще один модуль с заготовками процедур и функций, реализующих данные методы. В эти заготовки следует вписать соответствующий код (он показан выделенным шрифтом):
<pre>
//--------------------------------------------------------------
#include &lt;vcl.h&gt;
#pragma hdrstop
#include &lt;atl\atlvcl.h&gt;
#include "main3.h"
#include "main1.h"
//--------------------------------------------------------------
#pragma package(smart_init)
STDMETHODIMP TMyAuto3Impl::get_Width(int* Value)
{
  try
  {
     *Value=Form1->Width;
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::set_Width(int Value)
{
  try
  {
  Form1->Width=Value;
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::get_Visible(VARIANT_BOOL* Value)
{
  try
  {
      *Value=Form1->Visible;
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::set_Visible(VARIANT_BOOL Value)
{
  try
  {
   Form1->Visible=Value;
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::NewFile()
{
  try
  {
   Form1->Memo1->Lines->Clear();
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::SaveFile(BSTR Filename)
{
  try
  {
     Form1->Memo1->Lines->SaveToFile(Filename);
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::AddLine(BSTR Line)
{
  try
  {
    Form1->Memo1->Lines->Add(Line);
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
STDMETHODIMP TMyAuto3Impl::OpenFile(BSTR Filename)
{
  try
  {
Form1->Memo1->Lines->LoadFromFile(Filename);
  }
  catch(Exception &amp;e)
  {
    return Error(e.Message.c_str(), IID_IMyAuto3);
  }
  return S_OK;
};
//--------------------------------------------------------------
</pre>
<p align="justify">Скомпилируем и запустим сервер на выполнение. При этом он зарегистрируется в реестре. 
<center>
<p><img src="../../PICTURES/IT/AUTOSRV/AUTOSRV6.GIF" width=658 height=233 border=0 alt="Запись о сервере автоматизации в реестре Windows">
<p><i>Рис. 6. Запись о сервере автоматизации в реестре Windows</i>
</center>
<p align="justify">В действительности в разделах реестра HKEY_LOCAL_MASHINE\SOFTWARE и HKEY_CLASSES_ROOT содержится несколько записей, связанных с данным сервером и его интерфейсами, в том числе и информация о местоположении сервера.
<p align="justify">Если в дальнейшем отпадет необходимость в использовании созданного сервера автоматизации, рекомендуется запустить его с ключом /unregserver. В этом случае соответствующие записи будут удалены из реестра. Если же возникнет необходимость перенести сервер автоматизации в другой каталог, можно после этого просто запустить его снова, и при этом записи в реестре обновятся.
<p align="justify">Итак, мы создали настольное приложение, являющееся сервером автоматизации. Теперь, основываясь на информации о методах  класса его объекта  автоматизации, содержащейся в библиотеке типов, можно создавать приложения, управляющие этим сервером, с помощью довольно широкого спектра средств разработки (включающего  Delphi, C++Builder, Visual Basic, Visual C++ и др.). Создание контроллеров автоматизации будет рассмотрено в следующей статье данного цикла. 
<p>Координаты автора:<br>
Центр Информационных Технологий,<br>
Тел. (095)932-92-12, 932-92-13,<br>
<a href="mailto:elmanova@citmgu.ru">elmanova@citmgu.ru</a>,<br>
<a href="http://www.citmgu.ru">http://www.citmgu.ru</a>, <br>
<a href="http://www.citforum.ru">http://www.citforum.ru</a>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>