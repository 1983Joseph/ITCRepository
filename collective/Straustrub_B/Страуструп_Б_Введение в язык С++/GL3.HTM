<html>
<head>
<title>Бьярн Страустрап. Введение в язык Си++, Выражения и операторы</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<h1 align=center>         Глава 3 </h1>
<a name=gl3>
<h2 ALIGN=CENTER>        Выражения и операторы </h2>
<p><center>       С другой стороны, мы не можем игнорировать эффективность
<br>                                                      - Джон Бентли
</center>
<p>  C++ имеет  небольшой, но  гибкий набор различных видов операторов
для контроля потока управления в программе и богатый набор операций
для манипуляции  данными. С  наиболее общепринятыми  средствами вас
познакомит  один   законченный  пример.   После   него   приводится
резюмирующий обзор  выражений и  с  довольно  подробно  описываются
явное  описание   типа  и   работа  со   свободной  памятью.  Потом
представлена краткая  сводка операций,  а в конце обсуждаются стиль
выравнивания<a HREF=#*1>*<sup>1</sup></a> и комментарии.
<a name=gl3.1>
<h2 ALIGN=CENTER>     3.1 Настольный калькулятор </h2>
<table border=0>
<tr><td width=10></td><TD>   <a HREF=#gl3.1.1>        3.1.1 Программа синтаксического разбора           </a>
<tr><td width=10></td><TD>  <a HREF=#gl3.1.2>         3.1.2 Функция ввода            </a>                   
<tr><td width=10></td><TD>  <a HREF=#gl3.1.3>         3.1.3 Таблица имен               </a>                 
<tr><td width=10></td><TD>  <a HREF=#gl3.1.4>         3.1.4 Обработка ошибок      </a>                      
<tr><td width=10></td><TD>  <a HREF=#gl3.1.5>         3.1.5 Драйвер                          </a>           
<tr><td width=10></td><TD>  <a HREF=#gl3.1.6>       3.1.6 Параметры командной строки  </a>                
</table>
<p>  С операторами  и выражениями  вас  познакомит  приведенная  здесь
программа   настольного   калькулятора,   предоставляющего   четыре
стандартные арифметические операции над числами с плавающей точкой.
Пользователь может  также  определять  переменные.  Например,  если
вводится
<pre>
  r=2.5
  area=pi*r*r
</pre>
<br>(pi определено заранее), то программа калькулятора напишет:
<pre>
  2.5
  19.635
</pre>
<br>где 2.5  - результат  первой введенной строки, а 19.635 - результат
второй.
<br>  Калькулятор  состоит   из  четырех   основных  частей:  программы
синтаксического разбора  (parser'а), функции  ввода, таблицы имен и
управляющей  программы   (драйвера).  Фактически,  это  миниатюрный
компилятор, в  котором программа синтаксического разбора производит
синтаксический  анализ,   функция   ввода   осуществляет   ввод   и
лексический  анализ,   в  таблице   имен  хранится   долговременная
информация,  а   драйвер  распоряжается  инициализацией,  выводом  и
обработкой  ошибок.   Можно  было   бы  многое   добавить  в   этот
калькулятор, чтобы  сделать его  более полезным,  но в существующем
виде эта  программа и  так достаточно длинна (200 строк), и большая
часть дополнительных  возможностей просто  увеличит текст программы
не давая дополнительного понимания применения C++.
<a name=gl3.1.1>
<h3 ALIGN=CENTER>     3.1.1 Программа синтаксического разбора </h3>
<p>  Вот грамматика языка, допускаемого калькулятором:
<pre>
  program:
      END                    // END - это конец ввода
      expr_list END
  expr_list:
      expression PRINT      // PRINT - это или '\n' или ';'
      expression PRINT expr_list
  expression:
      expression + term
      expression - term
      term
  term:
      term / primary
      term * primary
      primary
  primary:
      NUMBER                // число с плавающей точкой в C++
      NAME                  // имя C++ за исключением '_'
      NAME = expression
      - primary
      ( expression )
</pre>
<br>Другими словами,  программа есть  последовательность строк.  Каждая
строка состоит  из одного или более выражений, разделенных запятой.
Основными элементами  выражения являются числа, имена и операции *,
/, +,  - (унарный  и бинарный)  и =.  Имена не  обязательно  должны
описываться до использования.
<br>  Используемый  метод  синтаксического  анализа  обычно  называется
рекурсивным спуском;  это популярный  и простой нисходящий метод. В
таком языке,  как C++,    в  котором  вызовы  функций  относительно
дешевы, этот  метод к  тому же  и эффективен.  Для каждого  правила
вывода  грамматики  имеется  функция,  вызывающая  другие  функции.
Терминальные символы   (например,  END, NUMBER, + и -) распознаются
лексическим  анализатором  get_token(),  а  нетерминальные  символы
распознаются функциями  синтаксического анализа  expr(),  term()  и
prim().  Как  только  оба  операнда  (под)выражения  известны,  оно
вычисляется; в  настоящем компиляторе  в  этой  точке  производится
генерация кода.
<br>  Программа  разбора   для  получения   ввода  использует   функцию
get_token(). Значение  последнего вызова  get_token()  находится  в
переменной curr_tok;  curr_tok имеет  одно из значений перечисления
token_value:
<pre>
  enum token_value {
      NAME        NUMBER    END
      PLUS='+'    MINUS='-'    MUL='*'    DIV='/'
      PRINT=';'    ASSIGN='='    LP='('    RP=')'
  };
  token_value curr_tok;
</pre>
 <br>  В каждой  функции разбора  предполагается, что  было обращение  к
get_token(), и  в curr_tok  находится очередной  символ, подлежащий
анализу.  Это  позволяет  программе  разбора  заглядывать  на  один
лексический символ  (лексему) вперед  и заставляет  функцию разбора
всегда читать  на одну  лексему больше,  чем используется правилом,
для обработки  которого она  была вызвана.  Каждая функция  разбора
вычисляет "свое"  выражение и  возвращает значение.  Функция expr()
обрабатывает сложение  и вычитание;  она состоит из простого цикла,
который ищет термы для сложения или вычитания:
<pre>
  double expr()                   // складывает  и вычитает
  {
      double left = term();
      for(;;)                     // ``навсегда``
          switch(curr_tok) {
          case PLUS:
              get_token();        // ест '+'
              left += term();
              break;
          case MINUS:
              get_token();        // ест '-'
              left -= term();
              break;
          default:
              return left;
          }
  }
</pre>
<br>Фактически сама функция делает не очень много. В манере, достаточно
типичной для  функций более  высокого уровня  в больших программах,
она вызывает  для выполнения  работы другие  функции. Заметьте, что
выражение 2-3+4 вычисляется как (2-3)+4, как указано грамматикой.
  Странная  запись   for(;;)  -   это  стандартный   способ  задать
бесконечный  цикл;  можно  произносить  это  как  "навсегда" <a HREF=#*2>*<sup>2</sup></a>.  Это
вырожденная  форма   оператора  for;   альтернатива   -   while(1).
Выполнение оператора  switch повторяется  до тех пор, пока не будет
найдено ни  + ни  -, и  тогда выполняется  оператор return в случае
default.
<br>  Операции +=  и  -=  используются  для  осуществления  сложения  и
вычитания. Можно  было бы  не изменяя смысла программы использовать
left=left+term() и  left=left-term(). Однако  left+=term() и  left-
=term()  не   только  короче,   но  к   тому   же   явно   выражают
подразумеваемое действие.  Для бинарной  операции @  выражение x@=y
означает x=x@y  за исключением  того, что x вычисляется только один
раз. Это применимо к бинарным операциям
<table border=0>
<TR><TD>  + </TD><TD>   -  </TD><TD>  *  </TD><TD>  /  </TD><TD>  %  </TD><TD>  &  </TD><TD>  |  </TD><TD>  ^  </TD><TD>  <<  </TD><TD>  >> </TD>
</table>
<br>поэтому возможны следующие операции присваивания:
<table border=0>
<TR><TD>  += </TD><TD>   -=  </TD><TD>  *= </TD><TD>   /= </TD><TD>   %=  </TD><TD>  &=  </TD><TD>  |=  </TD><TD>  ^=  </TD><TD>  <<=  </TD><TD>  >>= </TD>
</table>
<br>  Каждая  является  отдельной  лексемой,  поэтому  a+  =1  является
синтаксической ошибкой  из-за пробела  между +  и  =.  (%  является
операцией взятия  по модулю;  &,| и ^ являются побитовыми операциями
И, ИЛИ  и исключающее  ИЛИ; <<  и >>  являются операциями  левого и
правого сдвига).  Функции term()  и get_token() должны быть описаны
до expr().
<br>  Как организовать  программу в  виде набора  файлов, обсуждается в
<a HREF=GL4.HTM> Главе 4.</a>  За одним  исключением все  описания  в  данной  программе
настольного  калькулятора   можно  упорядочить   так,   чтобы   все
описывалось ровно один раз и до использования. Исключением является
expr(), которая  обращается к  term(), которая обращается к prim(),
которая в  свою очередь  обращается к expr(). Этот круг надо как-то
разорвать; описание
<pre>
  double expr();    // без этого нельзя
</pre>
<br>перед prim() прекрасно справляется с этим.
<br>  Функция  term()  аналогичным  образом  обрабатывает  умножение  и
сложение:
<pre>
  double term()                    // умножает и складывает
  {
      double left = prim();
      for(;;)
          switch(curr_tok)    {
          case MUL:
              get_token();         // ест '*'
              left *= prim();
              break;
          case DIV:
              get_token();         // ест '/'
              double d = prim();
              if (d == 0) return error("деление на 0");
              left /= d;
              break;
          default:
              return left;
          }
  }
</pre>
<br>  Проверка, которая  делается, чтобы  удостовериться в том, что нет
деления на  ноль, необходима,  поскольку результат  деления на ноль
не определен и  как правило  является роковым.  Функция error(char*)
будет описана позже. Переменная d вводится в программе там, где она
нужна, и сразу же инициализируется. Во многих языках описание может
располагаться  только   в  голове   блока.  Это  ограничение  может
приводить к  довольно скверному  искажению  стиля  программирования
и/или излишним  ошибкам. Чаще всего неинициализированные локальные
переменные являются  просто признаком  плохого  стиля;  исключением
являются переменные,  подлежащие инициализации посредством ввода, и
переменные векторного  или структурного  типа, которые нельзя удобно
инициализировать одними  присваиваниями <a HREF=#*3>*<sup>3</sup></a>. Заметьте,  что = является операцией присваивания, а == операцией сравнения.
<br>  Функция prim,  обрабатывающая primary,  написана в основном в том
же духе, не считая того, что немного реальной работы в ней все-таки
выполняется, и  нет нужды  в цикле,  поскольку мы попадаем на более
низкий уровень иерархии вызовов:
<pre>
  double prim()                 // обрабатывает primary (первичные)
  {
      switch (curr_tok) {
      case NUMBER:              // константа с плавающей точкой
          get_token();
          return number_value;
      case NAME:
          if (get_token() == ASSIGN) {
              name* n = insert(name_string);
              get_token();
              n->value = expr();
              return n->value;
          }
          return look(name-string)->value;
      case MINUS:               // унарный минус
          get_token();
          return -prim();
      case LP:
          get_token();
          double e = expr();
          if (curr_tok != RP) return error("должна быть )");
          get_token();
          return e;
      case END:
          return 1;
      default:
          return error("должно быть primary");
      }
  }
</pre>
<br>  При обнаружении  NUMBER (то  есть, константы с плавающей точкой),
возвращается  его  значение.  Функция  ввода  get_token()  помещает
значение в  глобальную  переменную  number_value.  Использование  в
программе  глобальных   переменных  часто   указывает  на  то,  что
структура не  совсем прозрачна,  что  применялась  некоторого  рода
оптимизация.  Здесь   дело   обстоит   именно   так.   Теоретически
лексический  символ   обычно  состоит  из  двух  частей:  значения,
определяющего вид лексемы (в данной программе token_value), и (если
необходимо) значения  лексемы. У  нас имеется  только одна  простая
переменная  curr_tok,  поэтому  для  хранения  значения  последнего
считанного NUMBER  понадобилась глобальная переменная number_value.
Это  работает   только  потому,  что  калькулятор  при  вычислениях
использует только одно число перед чтением со входа другого.
<br>  Так же,  как значение  последнего встреченного  NUMBER хранится в
number_value, в  name_string   в виде  символьной  строки  хранится
представление последнего прочитанного NAME. Перед тем, как что-либо
сделать  с  именем,  калькулятор  должен  заглянуть  вперед,  чтобы
посмотреть, осуществляется  ли присваивание  ему,  или  оно  просто
используется. В  обоих случаях надо справиться в таблице имен. Сама
таблица описывается  в<a HREF=#gl3.1.3> #3.1.3;</a>  здесь надо  знать только,  что  она
состоит из элементов вида:
<pre>
  srtuct name {
      char* string;
      char* next;
      double value;
  }
</pre>
<br>где next используется только функциями, которые поддерживают работу
с таблицей:
<pre>
  name* look(char*);
  name* insert(char*);
</pre>
<br>  Обе возвращают  указатель на  name, соответствующее  параметру  -
символьной строке;  look() выражает  недовольство, если имя не было
определено. Это  значит, что  в калькуляторе можно использовать имя
без  предварительного   описания,  но   первый   раз   оно   должно
использоваться в левой части присваивания.
<a name=gl3.1.2>
<h3 ALIGN=CENTER>     3.1.2 Функция ввода </h3>
<p>  Чтение ввода  - часто самая запутанная часть программы. Причина в
том, что  если программа должна общаться с человеком, то она должна
справляться с  его  причудами,  условностями  и  внешне  случайными
ошибками. Попытки  заставить человека  вести себя более удобным для
машины  образом   часто   (и   справедливо)   рассматриваются   как
оскорбительные. Задача  низкоуровневой программы  ввода состоит в
том, чтобы читать символы по одному и составлять из них лексические
символы более  высокого уровня. Далее эти лексемы служат вводом для
программ  более   высокого  уровня.   У  нас  ввод  низкого  уровня
осуществляется get_token(). Обнадеживает то, что написание программ
ввода низкого  уровня не  является ежедневной  работой;  в  хорошей
системе для этого будут стандартные функции.
<br>  Для калькулятора  правила ввода  сознательно были выбраны такими,
чтобы функциям  по работе  с потоками  было  неудобно  эти  правила
обрабатывать; незначительные изменения в определении лексем сделали
бы get_token() обманчиво простой.
<br>  Первая сложность  состоит в  том, что  символ новой  строки  '\n'
является для калькулятора существенным, а функции работы с потоками
считают его  символом пропуска.  То есть,  для  этих  функций  '\n'
значим только  как ограничитель лексемы. Чтобы преодолеть это, надо
проверять пропуски (пробел, символы табуляции и т.п.):
<pre>
  char ch
  do {    // пропускает пропуски за исключением '\n'
      if(!cin.get(ch)) return curr_tok = END;
  } while (ch!='\n' && isspace(ch));
</pre>
<br>  Вызов cin.get(ch)  считывает один  символ из  стандартного потока
ввода в ch. Проверка if(!cin.get(ch)) не проходит в случае, если из
cin нельзя  считать ни одного  символа; в  этом случае  возвращается
END,  чтобы   завершить  сеанс  работы  калькулятора.  Используется
операция  !  (НЕ),  поскольку  get()  возвращает  в  случае  успеха
ненулевое значение.
<br>  Функция (inline)  isspace() из  обеспечивает стандартную
проверку на  то, является  ли символ пропуском (<a HREF=GL8.HTM#gl8.4.1>#8.4.1</a>); isspace(c) возвращает ненулевое значение, если c является символом пропуска, и
ноль в  противном случае.  Проверка реализуется  в  виде  поиска  в
таблице,  поэтому  использование  isspace()  намного  быстрее,  чем
проверка на  отдельные символы  пропуска;  это  же  относится  и  к
функциям isalpha(),  isdigit() и  isalnum(), которые используются в
get_token().
<br>  После  того,   как  пустое   место  пропущено,   следующий  символ
используется для  определения того, какого вида какого вида лексема
приходит. Давайте  сначала рассмотрим  некоторые  случаи  отдельно,
прежде чем  приводить всю  функцию. Ограничители  лексем '\n' и ';'
обрабатываются так:
<pre>
  switch (ch) {
  case ';':
  case '\n':
      cin >> WS;    // пропустить пропуск
      return curr_tok=PRINT;
</pre>
<br>Пропуск  пустого   места  делать  необязательно,  но  он  позволяет
избежать повторных  обращений к  get_token(). WS  - это стандартный
пропусковый объект,  описанный в ; он используется только
для сброса  пропуска. Ошибка  во вводе  или конец  ввода  не  будут
обнаружены до следующего обращения к get_token(). Обратите внимание
на то,  как можно  использовать несколько  меток case (случаев) для
одной и  той же  последовательности операторов,  обрабатывающих эти
случаи. В  обоих случаях  возвращается лексема PRINT и помещается в
curr_tok.
<br>  Числа обрабатываются так:
<pre>
  case '0': case '1': case '2': case '3': case '4':
  case '5': case '6': case '7': case '8': case '9':
  case '.':
      cin.putback(ch);
      cin >> number_value;
      return curr_tok=NUMBER;
</pre>
<br>  Располагать метки  случаев case  горизонтально, а не вертикально,
не очень  хорошая мысль,  поскольку читать  это гораздо труднее, но
отводить по одной строке на каждую цифру нудно.
<br>  Поскольку операция  >> определена  также и  для чтения констант с
плавающей точкой  в double,  программирование этого  не  составляет
труда: сперва начальный символ (цифра или точка) помещается обратно
в cin, а затем можно считывать константу в number_value.
  Имя, то  есть лексема  NAME, определяется  как буква,  за которой
возможно следует несколько букв или цифр:
<pre>
  if (isalpha(ch)) {
      char* p = name_string;
      *p++ = ch;
      while (cin.get(ch) && isalnum(ch)) *p++ = ch;
      cin.putback(ch);
      *p = 0;
      return curr_tok=NAME;
  }
</pre>
<br>  Эта часть  строит в  name_string строку,  заканчивающуюся  нулем.
Функции isalpha()  и   isalnum() заданы  в ; isalnum(c) не
ноль, если c буква или цифра, ноль в противном случае.
<br>  Вот, наконец, функция ввода полностью:
<pre>
  token_value get_token()
  {
      char ch;
      do {    // пропускает пропуски за исключением '\n'
          if(!cin.get(ch)) return curr_tok = END;
      } while (ch!='\n' && isspace(ch));
      switch (ch) {
      case ';':
      case '\n':
          cin >> WS;    // пропустить пропуск
          return curr_tok=PRINT;
      case '*':
      case '/':
      case '+':
      case '-':
      case '(':
      case ')':
      case '=':
          return curr_tok=ch;
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9':
      case '.':
          cin.putback(ch);
          cin >> number_value;
          return curr_tok=NUMBER;
      default:            // NAME, NAME= или ошибка
          if (isalpha(ch)) {
              char* p = name_string;
              *p++ = ch;
              while (cin.get(ch) && isalnum(ch)) *p++ = ch;
              cin.putback(ch);
              *p = 0;
              return curr_tok=NAME;
          }
          error("плохая лексема");
          return curr_tok=PRINT;
      }
  }
</pre>
<br>  Поскольку     token_value  (значение   лексемы)   операции   было
определено  как  целое  значение  этой  операции <a HREF=#*4>*<sup>4</sup></a>,  обработка  всех операций тривиальна.
<a name=gl3.1.3>
<h3 ALIGN=CENTER>     3.1.3 Таблица имен </h3>
<p>  К таблице имен доступ осуществляется с помощью одной функции
<pre>
  name* look(char* p, int ins =0);
</pre>
<br>  Ее второй  параметр указывает,  нужно ли сначала поместить строку
символов  в  таблицу.  Инициализатор  =0  задает  параметр,  который
надлежит использовать по умолчанию, когда look() вызывается с одним
параметром. Это  дает удобство записи, когда look("sqrt2") означает
look("sqrt2",0), то  есть просмотр,  без помещения в таблицу. Чтобы
получить  такое   же  удобство  записи  для  помещения  в  таблицу,
определяется вторая функция:
<pre>
  inline name* insert(char* s) { return look(s,1);}
</pre>
<br>  Как уже отмечалось раньше, элементы этой таблицы имеют тип:
<pre>
  srtuct name {
      char* string;
      char* next;
      double value;
  }
</pre>
<br>Член next используется только для сцепления вместе имен в таблице.
  Сама таблица - это просто вектор указателей на объекты типа name:
<pre>
  const TBLSZ = 23;
  name* table[TBLSZ];
</pre>
<br>Поскольку  все  статические  объекты  инициализируются  нулем,  это
тривиальное описание  таблицы table  гарантирует  также  надлежащую
инициализацию.
<br>  Для нахождения  элемента в  таблице в  look() принимается простой
алгоритм хэширования  (имена с одним и тем же хэш-кодом зацепляются
вместе):
<pre>
  int ii = 0;        // хэширование
  char* pp = p;
  while (*pp) ii = ii<<1 ^ *pp++;
  if (ii < 0) ii = -ii;
  ii %= TBLSZ;
</pre>
<br>То есть, с помощью исключающего ИЛИ каждый символ во входной строке
"добавляется"  к  ii  ("сумме"  предыдущих  символов).  Бит  в  x^y
устанавливается   единичным    тогда   и    только   тогда,   когда
соответствующие биты  в x и y различны. Перед применением в символе
исключающего ИЛИ,  ii  сдвигается  на  один  бит  влево,  чтобы  не
использовать в  слове только  один байт.  Это можно было написать и
так:
<pre>
  ii <<= 1;
  ii ^= *pp++;
</pre>
<br>Кстати, применение  ^ лучше  и быстрее,  чем  +.  Сдвиг  важен  для
получения приемлемого хэш-кода в обоих случаях. Операторы
<pre>
  if (ii < 0) ii = -ii;
  ii %= TBLSZ;
</pre>
<br>обеспечивают, что  ii будет лежать в диапазоне 0...TBLSZ-1; % - это
операция взятия по модулю (еще называемая получением остатка).
<br>  Вот функция полностью:
<pre>
  extern int strlen(const char*);
  extern int strcmp(const char*, const char*);
  extern int strcpy(const char*, const char*);
  name* look(char* p, int ins =0)
  {
      int ii = 0;        // хэширование
      char* pp = p;
      while (*pp) ii = ii<<1 ^ *pp++;
      if (ii < 0) ii = -ii;
      ii %= TBLSZ;
      for (name* n=table[ii]; n; n=n->next)    // поиск
          if (strcmp(p,n->string) == 0) return n;
      if (ins == 0) error("имя не найдено");
      name* nn = new name;                     // вставка
      nn->string = new char[strlen(p)+1];
      strcpy(nn->string,p);
      nn->value = 1;
      nn->next = table[ii];
      table[ii] = nn;
      return nn;
  }
</pre>
<br>  После вычисления  хэш-кода ii  имя находится  простым  просмотром
через поля  next. Проверка  каждого name  осуществляется с  помощью
стандартной функции  strcmp(). Если строка найдена, возвращается ее
name, иначе добавляется новое name.
<br>  Добавление нового  name включает в себя создание нового объекта в
свободной  памяти   с  помощью   операции  new  (см. <a HREF=#gl3.2.6> #3.2.6</a>),  его инициализацию,  и   добавление  его   к  списку   имен.   Последнее
осуществляется просто путем помещения нового имени в голову списка,
поскольку это  можно делать  даже не  проверяя, имеется список, или
нет. Символьную  строку для  имени тоже нужно сохранить в свободной
памяти. Функция strlen() используется для определения того, сколько
памяти нужно,  new -  для выделения  этой памяти,  и strcpy() - для
копирования строки в память.
<a name=gl3.1.4>
<h3 ALIGN=CENTER>     3.1.4 Обработка ошибок </h3>
<p>  Поскольку программа  так проста,  обработка ошибок  не составляет
большого труда.  Функция обработки  ошибок просто  считает  ошибки,
пишет сообщение об ошибке и возвращает управление обратно:
<pre>
  int no_of_errors;
  double error(char* s) {
      cerr << "error: " << s << "\n";
      no_of_errors++;
      return 1;
  }
</pre>
<br>  Возвращается значение  потому, что  ошибки обычно  встречаются  в
середине  вычисления  выражения,  и  поэтому  надо  либо  полностью
прекращать вычисление,  либо возвращать  значение, которое  по всей
видимости  не  должно  вызвать  последующих  ошибок.  Для  простого
калькулятора  больше   подходит  последнее.   Если  бы  get_token()
отслеживала  номера   строк,   то   error()   могла   бы   сообщать
пользователю, где  приблизительно обнаружена  ошибка. Это наверняка
было бы полезно, если бы калькулятор использовался неитерактивно.
<br>  Часто бывает  так, что  после появления  ошибки программа  должна
завершиться,  поскольку  нет  никакого  разумного  пути  продолжить
работу. Это  можно сделать с помощью вызова exit(), которая очищает
все вроде  потоков вывода (<a HREF=GL8.HTM#gl8.3.2>#8.3.2</a>), а  затем  завершает  программу используя свой параметр в качестве ее возвращаемого значения. Более
радикальный  способ  завершения  программы  -  это  вызов  abort(),
которая обрывает  выполнение сразу  же или  сразу после  сохранения
где-то информации  для  отладчика  (дамп  памяти);  о  подробностях
справьтесь, пожалуйста, в вашем руководстве.
<a name=gl3.1.5>
<h3 ALIGN=CENTER>     3.1.5 Драйвер </h3>
<p>  Когда все  части программы на месте, нам нужен только драйвер для
инициализации и  всего того, что связано с запуском. В этом простом
примере main() может работать так:
<pre>
  int main()
  {
      // вставить предопределенные имена:
      insert("pi")->value = 3.1415926535897932385;
      insert("e")->value = 2.7182818284590452354;
      while (cin) {
          get_token();
          if (curr_tok == END) break;
          if (curr_tok == PRINT) continue;
          cout << expr() << "\n";
      }
      return no_of_errors;
  }
</pre>
<br>  Принято  обычно,   что  main()  возвращает  ноль  при  нормальном
завершении программы  и не  ноль в  противном случае,  поэтому  это
прекрасно может  сделать возвращение  числа ошибок. В данном случае
оказывается,  что   инициализация   нужна   только   для   введения
предопределенных имен в таблицу имен.
<br>  Основная работа  цикла -  читать выражения  и писать  ответ.  Это
делает строка:
<pre>
  cout << expr() << "\n";
</pre>
<br>  Проверка cin  на каждом  проходе  цикла  обеспечивает  завершение
программы в  случае, если с потоком ввода что-то не так, а проверка
на END  обеспечивает корректный  выход из  цикла, когда get_token()
встречает конец  файла.  Оператор    break  осуществляет  выход  из
ближайшего содержащего  его оператора  switch или  цикла (то  есть,
оператора for, оператора while или оператора do). Проверка на PRINT
(то есть,  на '\n'  или  ';')  освобождает  expr()  от  обязанности
обрабатывать  пустые   выражения.  Оператор   continue   равносилен
переходу к самому концу цикла, поэтому в данном случае
<pre>
  while (cin) {
      // ...
      if (curr_tok == PRINT) continue;
      cout << expr() << "\n";
  }
</pre>
<br>эквивалентно
<pre>
  while (cin) {
      // ...
      if (curr_tok == PRINT) goto end_of_loop;
      cout << expr() << "\n";
      end_of_loop
  }
</pre>
<br>  Более подробно циклы описываются в #с.9.
<a name=gl3.1.6>
<h3 ALIGN=CENTER>     3.1.6 Параметры командной строки </h3>
<p>  После того,  как  программа  была  написана  и  оттестирована,  я
заметил, что  часто набирать выражения  на клавиатуре в стандартный
ввод надоедает,  поскольку обычно использование программы состоит в
вычислении одного  выражения. Если  бы можно  было представлять это
выражение как  параметр командной  строки, не  приходилось  бы  так
много нажимать на клавиши.
<p>  Как уже  говорилось, программа  запускается вызовом main(). Когда
это происходит,  main() получает  два параметра:  указывающий число
параметров, обычно  называемый argc,  и вектор  параметров,  обычно
называемый argv.  Параметры -  это символьные  строки, поэтому argv
имеет  тип  char*[argc].  Имя  программы  (так,  как  оно  стоит  в
командной строке)  передается  в  качестве  argv[0],  поэтому  argc
всегда не меньше единицы. Например, в случае команды
<pre>
  dc 150/1.1934
</pre>
<br>параметры имеют значения:
<pre>
  argc        2
  argv[0]        "dc"
  argv[1]        "150/1.1934"
</pre>
<br>  Научиться пользоваться  параметрами  командной  строки  несложно;
сложность   состоит    в   том,    как    использовать    их    без
перепрограммирования.  В   данном  случае  это  оказывается  совсем
просто, поскольку поток ввода можно связать с символьной строкой, а
не с файлом (<a HREF=GL8.HTM#gl8.5>#8.5</a>). Например, можно заставить cin читать символы из стандартного ввода:
<pre>
  int main(int argc, char* argv[])
  {
      switch(argc) {
      case 1:        // читать из стандартного ввода
          break;
      case 2:        // читать параметр строку
          cin = *new istream(strlen(argv[1]),argv[1]);
          break;
      default:
          error("слишком много параметров");
          return 1;
      }
      // как раньше
  }
</pre>
<br>  Программа осталась  без изменений,  за исключением  добавления  в
main() параметров  и  использования  этих  параметров  в  операторе
switch. Можно  было бы  легко модифицировать  main() так, чтобы она
получала несколько  параметров командной строки, но это оказывается
ненужным, особенно потому, что несколько выражений можно передавать
как один параметр:
<pre>
  dc "rate=1.1934;150/rate;19.75/rate;217/rate"
</pre>
<br>  Здесь  кавычки  необходимы,  поскольку  ;  является  разделителем
команд в системе UNIX.
<a name=gl3.2>
<h2 ALIGN=CENTER>     3.2 Краткая сводка операций </h2>
<table border=0>
<tr><td width=10></td><TD>    <a HREF=#gl3.2.1>       3.2.1 Круглые скобки         </a>                     
<tr><td width=10></td><TD>    <a HREF=#gl3.2.2>       3.2.2 Порядок вычисления     </a>                  
<tr><td width=10></td><TD>    <a HREF=#gl3.2.3>       3.2.3 Увеличение и уменьшение </a><a HREF=#*5>*<sup>5</sup> </a>                   
<tr><td width=10></td><TD>   <a HREF=#gl3.2.4>  3.2.4 Побитовые логические операции     </a>          
<tr><td width=10></td><TD>     <a HREF=#gl3.2.5>      3.2.5 Преобразование типа      </a>                
<tr><td width=10></td><TD>     <a HREF=#gl3.2.6>      3.2.6 Свободная память      </a>                     
</table>
<p>  Операции  C++  подробно  и  систематически  описываются  в  #с.7;
прочитайте, пожалуйста,  этот раздел.  Здесь же  приводится краткая
сводка и  некоторые примеры.  После каждой  операции приведено одно
или   более   ее   общеупотребительных   названий   и   пример   ее
использования. В  этих примерах имя_класса - это имя класса, член -
имя члена,  объект -  выражение, дающее в результате объект класса,
указатель  -  выражение,  дающее  в  результате  указатель,  выр  -
выражение, а lvalue - выражение, денотирующее неконстантный объект.
Тип может  быть совершенно  произвольным именем  типа (со  *, ()  и
т.п.) только  когда он  стоит в  скобках, во всех остальных случаях
существуют ограничения.
<br>  Унарные операции  и операции  присваивания правоассоциативны, все
остальные левоассоциативны. Это значит, что a=b=c означает a=(b=c),
a+b+c означает (a+b)+c, и *p++ означает *(p++), а не (*p)++.
<h4 align=center>   Сводка Операций (часть 1) </h4>
<hr noshade>   
<pre>
::        разрешение области видимости   имя_класса :: член
   ::        глобальное                     :: имя
</pre>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   ->   </TD><TD>     выбор члена      </TD><TD>              указатель->член </TD>
<TR><TD>   []    </TD><TD>      индексация       </TD><TD>               указатель [ выр ] </TD>
<TR><TD>   ()    </TD><TD>    вызов функции   </TD><TD>               выр (список_выр) </TD>
<TR><TD>   ()    </TD><TD>   построение значения      </TD><TD>       тип (список_выр) </TD>
<TR><TD>   sizeof     </TD><TD> размер объекта          </TD><TD>        sizeof выр</TD>
<TR><TD>   sizeof     </TD><TD> размер типа                </TD><TD>     sizeof ( тип ) </TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   ++    </TD><TD>     приращение после    </TD><TD>         lvalue++</TD>
<TR><TD>   ++    </TD><TD>     приращение до          </TD><TD>     ++lvalue</TD>
<TR><TD>   --      </TD><TD>   уменьшение после      </TD><TD>     lvalue--</TD>
<TR><TD>   --      </TD><TD>  уменьшение до            </TD><TD>       --lvalue</TD>
<TR><TD>   ~      </TD><TD>   дополнение                  </TD><TD>     ~ выр</TD>
<TR><TD>   !       </TD><TD>    не                                 </TD><TD>  ! выр</TD>
<TR><TD>   -       </TD><TD>   унарный минус            </TD><TD>       - выр</TD>
<TR><TD>   +      </TD><TD>   унарный плюс             </TD><TD>    + выр</TD>
<TR><TD>   &     </TD><TD>    адрес объекта             </TD><TD>      & lvalue</TD>
<TR><TD>   *      </TD><TD>  разыменование          </TD><TD>         * выр</TD>
<TR><TD>   new       </TD><TD>   создание (размещение) </TD><TD>      new тип</TD>
<TR><TD>   delete    </TD><TD>   уничтожение (освобождение) </TD><TD> delete указатель</TD>
<TR><TD>   delete[]  </TD><TD> уничтожение вектора        </TD><TD>     delete[ выр ]
   указатель</TD>
<TR><TD>   ()      </TD><TD>   приведение (преобразование типа)  </TD><TD>   ( тип ) выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   *      </TD><TD>    умножение          </TD><TD>             выр * выр</TD>
<TR><TD>   /      </TD><TD>    деление                 </TD><TD>        выр / выр</TD>
<TR><TD>   %    </TD><TD>      взятие по модулю (остаток) </TD><TD>   выр % выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   +      </TD><TD>    сложение (плюс) </TD><TD>          выр + выр</TD>
<TR><TD>   -       </TD><TD>   вычитание (минус) </TD><TD>         выр - выр</TD>
</table>
<br>  В  каждой  отчерченной  части  находятся  операции  с  одинаковым
приоритетом. Операция  имеет  приоритет  больше,  чем  операции  из
частей, расположенных  ниже. Например:  a+b*c означает a+(b*c), так
как *  имеет приоритет  выше, чем  +,  а  a+b-c  означает  (a+b)-c,
поскольку  +   и  -  имеют  одинаковый  приоритет  (и  поскольку  +
левоассоциативен).
<h4 align=center>        Сводка Операций (часть 2) </h4>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   <<     </TD><TD>  сдвиг влево           </TD><TD>          lvalue << выр</TD>
<TR><TD>   >>    </TD><TD>   сдвиг вправо          </TD><TD>          lvalue >> выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   <     </TD><TD>   меньше                  </TD><TD>        выр < выр</TD>
<TR><TD>   <=   </TD><TD>    меньше или равно     </TD><TD>           выр <= выр</TD>
<TR><TD>   >     </TD><TD>   больше                    </TD><TD>      выр > выр</TD>
<TR><TD>   >=   </TD><TD>     больше или равно      </TD><TD>          выр >= выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    ==   </TD><TD>    равно            </TD><TD>               выр == выр</TD>
<TR><TD>   !=     </TD><TD>  не равно        </TD><TD>                выр != выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    &     </TD><TD>     побитовое И        </TD><TD>             выр & выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   ^     </TD><TD>      побитовое исключающее ИЛИ  </TD><TD>     выр ^ выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    |      </TD><TD>     побитовое включающее ИЛИ   </TD><TD>     выр | выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>   &&    </TD><TD>   логическое И          </TD><TD>          выр && выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    ||   </TD><TD>    логическое включающее ИЛИ     </TD><TD>  выр || выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    ? : </TD><TD>  арифметический if    </TD><TD>           выр ? выр : выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>    =    </TD><TD>    простое присваивание      </TD><TD>      lvalue = выр</TD>
<TR><TD>   *=   </TD><TD>    умножить и присвоить     </TD><TD>       lvalue = выр</TD>
<TR><TD>   /=    </TD><TD>   разделить и присвоить     </TD><TD>      lvalue /= выр</TD>
<TR><TD>   %=  </TD><TD>     взять по модулю и присвоить  </TD><TD>   lvalue %= выр</TD>
<TR><TD>   +=  </TD><TD>     сложить и присвоить     </TD><TD>        lvalue += выр</TD>
<TR><TD>   -=    </TD><TD>   вычесть и присвоить      </TD><TD>       lvalue -= выр</TD>
<TR><TD>   <<=  </TD><TD>    сдвинуть влево и присвоить   </TD><TD>   lvalue <<= выр</TD>
<TR><TD>   >>=   </TD><TD>   сдвинуть вправо и присвоить  </TD><TD>   lvalue >>= выр</TD>
<TR><TD>   &=   </TD><TD>    И и присвоить       </TD><TD>            lvalue &= выр</TD>
<TR><TD>   |=     </TD><TD>  включающее ИЛИ и присвоить  </TD><TD>    lvalue |= выр</TD>
<TR><TD>   ^=    </TD><TD>   исключающее ИЛИ и присвоить  </TD><TD>   lvalue ^= выр</TD>
</table>
<hr noshade>   
<table border=0 width="100%">
<TR><TD>     , </TD><TD>    запятая (последование) </TD><TD>       выр , выр</TD>
</table>
<a name=gl3.2.1>
<h3 ALIGN=CENTER>     3.2.1 Круглые скобки </h3>
<p>  Скобками синтаксис  C++ злоупотребляет;  количество  способов  их
использования  приводит   в  замешательство:  они  применяются  для
заключения в  них параметров  в вызовах  функций, в них заключается
тип в  преобразовании типа  (приведении к типу), в именах типов для
обозначения функций, а также для разрешения конфликтов приоритетов.
К счастью,  последнее требуется не слишком часто, потому что уровни
приоритета и  правила  ассоциативности  определены  таким  образом,
чтобы выражения  "работали ожидаемым  образом" (то  есть,  отражали
наиболее привычный способ употребления). Например, значение
<pre>
  if (i<=0 || max
</pre>
<a name=gl3.2.2>
<h3 ALIGN=CENTER> 3.2.2 Порядок вычисления </h3>
<p>  Порядок вычисления подвыражений в выражении не определен. Например
<pre>
  int i = 1;
  v[i] = i++;
</pre>
<br>может вычисляться  или как  v[1]=1, или  как v[2]=1. При отсутствии
ограничений на  порядок вычисления  выражения может  генерироваться
более  хороший  код.  Было  бы  замечательно,  если  бы  компилятор
предупреждал   о    подобных   неоднозначностях,   но   большинство
компиляторов этого не делают.
<br>  Относительно операций
<pre>
  ,    &&    ||
</pre>
<br>гарантируется, что их левый операнд вычисляется раньше, чем правый.
Например, b=(a=2,a=1)  присвоит b  3. В  <a HREF=#gl3.3.1>#3.3.1</a> приводятся  примеры использования &&  и  ||.  Заметьте,  что  операция  последования  ,
(запятая) логически отличается от запятой, которая используется для
разделения параметров в вызове функции. Рассмотрим
<pre>
  f1(v[i],i++);       // два параметра
  f2( (v[i],i++) )    // один параметр
</pre>
<br>В вызове  f1 два  параметра,  v[i]  и  i++,  и  порядок  вычисления
выражений-параметров не определен.  Зависимость  выражения-параметра
от  порядка   вычисления    -  это  очень  плохой  стиль,  а  также
непереносимо. В  вызове f2  один  параметр,  выражение  с  запятой,
которое эквивалентно i++.
<br>  С помощью  скобок нельзя  задать  порядок  вычисления.  Например,
a*(b/c) может  вычисляться и  как (a*b)/c,  поскольку *  и /  имеют
одинаковый  приоритет.   В  тех   случаях,  когда   важен   порядок
вычисления,  можно  вводить  дополнительную  переменную,  например,
(t=b/c,a*t).
<a name=gl3.2.3>
<h3 ALIGN=CENTER>     3.2.3 Увеличение и уменьшение<a HREF=#*5>* <sup>5</sup></h3></a>
<p>  Операция ++  используется для  явного выражения приращения вместо
его  неявного   выражения   с   помощью   комбинации   сложения   и
присваивания. По  определению ++lvalue  означает lvalue+=1,  что  в
свою очередь  означает lvalue=lvalue+1  при условии,  что lvalue не
вызывает  никаких   побочных  эффектов.   Выражение,   обозначающее
(денотирующее) объект,  который должен  быть увеличен,  вычисляется
один раз  (только). Аналогично, уменьшение выражается операцией --.
Операции ++  и  --  могут  применяться  и  как  префиксные,  и  как
постфиксные. Значением  ++x является  новое (то  есть  увеличенное)
значение x.  Например, y=++x  эквивалентно y=(x+=1).  Значение x++,
напротив, есть  старое значение  x.  Например,  y=x++  эквивалентно
y=(t=x,x+=1,t), где t - переменная того же типа, что и x.
<br>  Операции приращения  особенно полезны для увеличения и уменьшения
переменных в  циклах. Например,  оканчивающуюся нулем  строку можно
копировать так:
<pre>
  inline void cpy(char* p, const char* q)
  {
      while (*p++ = *q++) ;
  }
</pre>
<br>Напомню,  что  увеличение  и  уменьшение  указателей,  так  же  как
сложение  и   вычитание  указателей,   осуществляется  в   терминах
элементов вектора,  на которые  указывает указатель; p++ приводит к
тому, что p указывает на следующий элемент. Для указателя p типа T*
по определению выполняется следующее:
<pre>
  long(p+1) == long(p)+sizeof(T);
</pre>
<a name=gl3.2.4>
<h3 ALIGN=CENTER>     3.2.4 Побитовые логические операции </h3>
<p>  Побитовые логические операции
<pre>
  &    |    ^    ~    >>    <<
</pre>
<br>применяются к целым, то есть к объектам типа char, short, int, long
и их unsigned аналогам, результаты тоже целые.
<br>  Одно из  стандартных применений  побитовых логических  операций -
реализация маленького  множества (вектора  битов). В  этом  случае
каждый бит  беззнакового целого представляет один член множества, а
число  членов   ограничено  числом   битов.  Бинарная   операция  &
интерпретируется как  пересечение,  |  как  объединение,  а  ^  как
разность. Для именования членов такого множества можно использовать
перечисление. Вот  маленький пример,  заимствованный из  реализации
(не пользовательского интерфейса) :
<pre>
  enum state_value { _good=0, _eof=1, _fail=2, _bad=4};
                   // хорошо, конец файла, ошибка, плохо
</pre>
<br>Определение _good  не является  необходимым. Я  просто хотел, чтобы
состояние, когда  все в  порядке, имело  подходящее имя.  Состояние
потока можно установить заново следующим образом:
<pre>
  cout.state = _good;
</pre>
<br>  Например, так  можно проверить,  не был  ли  испорчен  поток  или
допущена операционная ошибка:
<pre>
  if (cout.state&(_bad|_fail)) // не good
</pre>
<br> Еще  одни  скобки  необходимы,  поскольку  &  имеет  более  высокий
приоритет, чем |.
<br>  Функция, достигающая конца ввода, может сообщать об этом так:
<pre>
  cin.state |= _eof;
</pre>
<br>Операция |=  используется потому, что поток уже может быть испорчен
(то есть, state==_bad), поэтому
<pre>
  cin.state = _eof;
</pre>
<br> очистило бы этот признак. Различие двух потоков можно находить так:
<pre>
  state_value diff = cin.state^cout.state;
</pre>
<br>В случае  типа stream_state  (состояние потока)  такая разность  не
очень нужна,  но для  других похожих  типов она  оказывается  самой
полезной. Например,  при  сравнении  вектора  бит,  представляющего
множество   прерываний,    которые   обрабатываются,    с   другим,
представляющим прерывания, ждущие обработки.
<br>  Следует   заметить,    что   использование   полей  (<a HREF=GL2.HTM#gl2.5.1>#2.5.1</a>)   в действительности является сокращенной записью сдвига и маскирования
для извлечения  полей бит из слова. Это, конечно, можно сделать и с
помощью побитовых логических операций, Например, извлечь средние 16
бит из 32-битового int можно следующим образом:
<pre>
  unsigned short middle(int a) { return (a>>8)&0xffff; }
</pre>
<br>  Не  путайте   побитовые   логические   операции   с   логическими
операциями:
<pre>
  &&    ||    !
</pre>
<br>  Последние возвращают  0 или 1, и они главным образом используются
для записи  проверки в  операторах  if,  while  или  for (<a HREF=#gl3.3.1>#3.3.1</a>).
Например, !0  (не ноль)  есть значение  1, тогда как ~0 (дополнение
нуля)  есть   набор  битов  все-единицы,  который  обычно  является
значением -1.
<a name=gl3.2.5> 
<h3 ALIGN=CENTER>     3.2.5 Преобразование типа </h3>
<p>  Бывает необходимо  явно  преобразовать  значение  одного  типа  в
значение другого.  Явное преобразование  типа дает  значение одного
типа для данного значения другого типа. Например:
<pre>
  float r = float(1);
</pre>
<br>перед присваиванием  преобразует целое  значение  1  к  значению  с
плавающей точкой  1.0. Результат  преобразования типа  не является
lvalue, поэтому ему нельзя присваивать (если только тип не является
ссылочным типом).
<br>  Есть два  способа записи явного преобразования типа: традиционная
в C  запись приведения  к типу  (double)a и  функциональная  запись
double(a). Функциональная  запись не  может применяться  для типов,
которые не  имеют простого  имени.  Например,  чтобы  преобразовать
значение  к   указательному  типу   надо  или  использовать  запись
приведения
<pre>
  char* p = (char*)0777;
</pre>
<br>или определить новое имя типа:
<pre>
  typedef char* Pchar;
  char* p = Pchar(0777);
</pre>
<br>По моему  мнению, функциональная  запись  в  нетривиальных  случаях
предпочтительна. Рассмотрим два эквивалентных примера
<pre>
  Pname n2 = Pbase(n1->tp)->b_name;        // функциональная запись
  Pname n3 = ((Pbase)n2->tp)->b_name;        // запись приведения к
  типу
</pre>
<br>Поскольку операция  -> имеет  больший  приоритет,  чем  приведение,
последнее выражение интерпретируется как
<pre>
  ((Pbase)(n2->tp))->b_name
</pre>
<br>С помощью  явного преобразования  типа к  указательным типам  можно
сымитировать,  что   объект  имеет   совершенно  произвольный  тип.
Например:
<pre>
  any_type* p = (any_type*)&some_object;
</pre>
<br>позволит работать  посредством p  с некоторым  объектом some_object
как с любым типом any_type.
<br>  Когда преобразование  типа не  необходимо, его  следует избегать.
Программы, в которых используется много явных преобразований типов,
труднее понимать,  чем те,  в которых это не делается. Однако такие
программы легче  понимать, чем  программы, просто  не  использующие
типы для  представления понятий  более высокого  уровня  (например,
программу, которая оперирует регистром устройства с помощью  сдвига
и маскирования,  вместо того,  чтобы определить подходящую struct и
оперировать  ею; см. <a HREF=GL2.HTM#gl2.5.2> #2.5.2 </a>).  Кроме  того,  правильность  явного преобразования типа  часто критическим образом зависит от понимания
программистом  того,   каким  образом   объекты   различных   типов
обрабатываются в  языке, и  очень часто от подробностей реализации.
Например:
<pre>
  int i = 1;
  char* pc = "asdf";
  int* pi = &i;
  i = (int)pc;
  pc = (char*)i;    // остерегайтесь: значение pc может измениться
                    // на некоторых машинах
                    // sizeof(int)
</pre>
<a name=gl3.2.6>
<h3 ALIGN=CENTER> 3.2.6 Свободная память </h3>
<p>  Именованный объект является либо статическим, либо автоматическим
см. <a HREF=GL2.HTM#gl2.1.3>#2.1.3</a>).  Статический  объект  размещается  во  время  запуска программы  и  существует  в  течение  всего  выполнения  программы.
Автоматический объект размещается каждый раз при входе в его блок и
существует только  до тех пор, пока из этого блока не вышли. Однако
часто бывает полезно создать новый объект, существующий до тех пор,
пока он  не станет  больше не  нужен. В  частности,  часто  полезно
создать  объект,  который  можно  использовать  после  возврата  из
функции, где  он создается.  Такие объекты  создает операция new, а
в последствие уничтожать  их можно  операцией delete.  Про  объекты,
выделенные с  помощью операции  new, говорят,  что они  в свободной
памяти. Такими  объектами  обычно  являются  вершины  деревьев  или
элементы связанных  списков, являющиеся  частью  большей  структуры
данных, размер которой не может быть известен на стадии компиляции.
Рассмотрим,  как   можно  было   бы  написать   компилятор  в  духе
написанного  настольного   калькулятора.  Функции   синтаксического
анализа могут  строить древовидное представление выражений, которое
будет использоваться при генерации кода. Например:
<pre>
  struct enode {
      token_value oper;
      enode* left;
      enode* right;
  };
  enode* expr()
  {
  enode* left = term();
  for(;;)
      switch(curr_tok) {
      case PLUS:
      case MINUS:
          get_token();
          enode* n = new enode;
          n->oper = curr_tok;
          n->left = left;
          n->right = term();
          left = n;
          break;
      default:
          return left;
      }
  }
</pre>
<br>Получающееся дерево генератор кода может использовать например так:
<pre>
  void generate(enode* n)
  {
      switch (n->oper) {
      case PLUS:
          // делает нечто соответствующее
          delete n;
      }
  }
</pre>
<br>  Объект, созданный  с помощью  new, существует,  пока он  не будет
явно    уничтожен  delete,  после  чего  пространство,  которое  он
занимал,  опять  может  использоваться  new.    Никакого  "сборщика
мусора",  который   ищет  объекты,   на  которые   нет  ссылок,   и
предоставляет их  в распоряжение  new, нет.  Операция delete  может
применяться только к указателю, который был возвращен операцией new,
или к нулю. Применение delete к нулю не вызывает никаких действий.
<br>  С помощью new можно также создавать вектора объектов. Например:
<pre>
  char* save_string(char* p)
  {
      char* s = new char[strlen(p)+1];
      strcpy(s,p);
      return s;
  }
</pre>
<br>Следует заметить,  что чтобы  освободить  пространство,  выделенное
new, delete  должна иметь возможность определить размер выделенного
объекта. Например:
<pre>
  int main(int argc, char* argv[])
  {
      if (argc < 2) exit(1);
      char* p = save_string(argv[1]);
      delete p;
  }
</pre>
<br>Это приводит к тому, что объект, выделенный стандартной реализацией
new, будет  занимать больше  места, чем  статический объект (обычно,
больше на одно слово).
<br>  Можно также  явно указывать размер вектора в операции уничтожения
delete. Например:
<pre>
  int main(int argc, char* argv[])
  {
      if (argc < 2) exit(1);
      int size = strlen(argv[1])+1;
      char* p = save_string(argv[1]);
      delete[size] p;
  }
</pre>
<br>Заданный пользователем  размер вектора  игнорируется за исключением
некоторых типов, определяемых пользователем (<a HREF=GL5_2.HTM#gl5_2.5.5>#5.5.5</a>).
<br>  Операции свободной памяти реализуются функциями (#с.7.2.3):
<pre>
  void operator new(long);
  void operator delete(void*);
</pre>
<br>  Стандартная реализация new не инициализирует возвращаемый объект.
<br>  Что происходит,  когда  new  не  находит  памяти  для  выделения?
Поскольку  даже  виртуальная  память  конечна,  это  иногда  должно
происходить. Запрос вроде
<pre>
  char* p = new char[100000000];
</pre>
<br>как правило,  приводит к каким-то неприятностям. Когда у new ничего
не  получается,   она  вызывает  функцию,  указываемую  указателем
_new_handler (указатели на функции обсуждаются в <a HREF=GL4.HTM#gl4.6.9> #4.6.9</a>). Вы можете задать указатель  явно или  использовать функцию set_new_handler().
Например:
<pre>
  #include
  void out_of_store()
  {
      cerr << "операция new не прошла: за пределами памяти\n";
      exit(1);
  }
  typedef void (*PF)();    // тип указатель на функцию
  extern PF set_new_handler(PF);
  main()
  {
      set_new_handler(out_of_store);
      char* p = new char[100000000];
      cout << "сделано, p = " << long(p) << "\n";
  }
</pre>
<br>как правило,  не будет  писать  "сделано",  а  будет  вместо  этого
выдавать
<pre>
  операция new не прошла: за пределами памяти
</pre>
<br>  _new_handler может делать и кое-что поумнее, чем просто завершать
выполнение программы.  Если вы  знаете, как  работают new и delete,
например, потому,  что вы  задали свои собственные operator new() и
operator  delete(),  программа  обработки  может  попытаться  найти
некоторое  количество   памяти,  которое   возвратит  new.  Другими
словами, пользователь  может сделать  сборщик мусора, сделав, таким
образом, использование delete необязательным. Но это, конечно, все-
таки задача не для начинающего.
<br>  По историческим  причинам new просто возвращает указатель 0, если
она не  может найти  достаточное количество  памяти и  не был задан
никакой _new_handler. Например
<pre>
  include
  main()
  {
      char* p = new char[100000000];
      cout << "сделано, p = " << long(p) << "\n";
  }
</pre>
<br>выдаст
<pre>
  сделано, p = 0
</pre>
<br>Вам  сделали   предупреждение!  Заметьте,   что  тот,   кто  задает
_new_handler, берет на себя заботу по проверке истощения памяти при
каждом использовании  new в  программе (за исключением случая, когда
пользователь задал  отдельные подпрограммы  для размещения объектов
заданных типов, определяемых пользователем; см. <a HREF=GL5_2.HTM#gl5_2.5.6> #5.5.6</a>).
<a name=gl3.3>
<h2 ALIGN=CENTER>     3.3 Сводка операторов </h2>
<table border=0>
<tr><td width=10></td><TD>      <a HREF=#gl3.3.1>     3.3.1 Проверки                        </a>          
<tr><td width=10></td><TD>      <a HREF=#gl3.3.2>     3.3.2 Goto                               </a>      
</table>
<p>  Операторы  C++   систематически  и  полностью  изложены  в  #с.9,
прочитайте, пожалуйста,  этот раздел.  А здесь  приводится  краткая
сводка и некоторые примеры.
<h4 ALIGN=CENTER>            Синтаксис оператора </h4>
<hr noshade>   
<pre>
   оператор:
       описание
       {список_операторов opt}
       выражение opt
       if ( выражение ) опреатор
       if ( выражение ) оператор else оператор
       switch ( выражение ) оператор
       while ( выражение ) оператор
       do оператор while (выражение)
       for ( оператор  выражение opt ; выражение opt ) оператор
       case константное_выражение : оператор
       default : оператор
       break ;
       continue ;
       return выражение opt ;
       goto идентификатор ;
       идентификатор : оператор
       список_операторов:
           оператор
           оператор список_операторов
</pre>
<br>  Заметьте, что  описание является оператором, и что нет операторов
присваивания и  вызова  процедуры.  Присваивание  и  вызов  функции
обрабатываются как выражения.
<a name=gl3.3.1>
<h3 ALIGN=CENTER>     3.3.1 Проверки </h3>
<p>  Проверка значения  может осуществляться  или оператором  if,  или
оператором switch:
<pre>
  if ( выражение ) оператор
  if ( выражение ) оператор else оператор
  switch ( выражение ) оператор
</pre>
<br>  В C++ нет отдельного булевского типа. Операции сравнения
<pre>
  ==    !=    <    <=    >    >=
</pre>
<br>возвращают целое  1, если сравнение истинно, иначе возвращают 0. Не
так уж  непривычно видеть,  что ИСТИНА  определена как  1,  а  ЛОЖЬ
определена как 0.
<br>  В операторе  if первый  (или единственный) оператор выполняется в
том случае,  если выражение  ненулевое,  иначе  выполняется  второй
оператор (если  он задан).  Отсюда следует,  что в качестве условия
может использоваться  любое целое  выражение. В  частности, если  a
целое, то
<pre>
  if (a) // ...
</pre>
<br>эквивалентно
<pre>
  if (a != 0) // ...
</pre>
<br>  Логические операции
<pre>
  &&    ||    !
</pre>
<br>наиболее часто  используются в  условиях. Операции && и || не будут
вычислять второй аргумент, если это ненужно. Например:
<pre>
  if (p && 1count) // ...
</pre>
<br> вначале проверяет,  является ли  p не нулем, и только если это так,
то проверяет 1count.
<br>  Некоторые простые  операторы if  могут быть  с удобством заменены
выражениями арифметического if. Например:
<pre>
  if (a <= d)
      max = b;
  else
      max = a;
</pre>
<br>лучше выражается так:
<pre>
  max = (a<=b) ? b : a;
</pre>
<br>Скобки вокруг  условия необязательны,  но я  считаю, что  когда они
используются, программу легче читать.
<br>  Некоторые простые  операторы switch  можно по-другому  записать в
виде набора операторов if. Например:
<pre>
  switch (val) {
  case 1:
      f();
      break;
  case 2;
      g();
      break;
  default:
      h();
      break;
  }
</pre>
<br>иначе можно было бы записать так:
<pre>
  if (val == 1)
      f();
  else if (val == 2)
      g();
  else
      h();
</pre>
<br>  Смысл тот  же, однако  первый вариант  (switch) предпочтительнее,
поскольку  в   этом  случае   явно  выражается   сущность  действия
(сопоставление значения  с рядом констант). Поэтому в нетривиальных
случаях оператор switch читается легче.
<br>  Заботьтесь о  том, что  switch должен  как-то  завершаться,  если
только вы не хотите, чтобы выполнялся следующий case. Например:
<pre>
  switch (val) {    // осторожно
  case 1:
      cout << "case 1\n";
  case 2;
      cout << "case 2\n";
  default:
      cout << "default: case не найден\n";
  }
</pre>
<br>при val==1 напечатает
<pre>
  case 1
  case 2
  default: case не найден
</pre>
<br>к великому изумлению непосвященного. Самый обычный способ завершить
случай - это break, иногда можно даже использовать goto. Например:
<pre>
  switch (val) {    // осторожно
  case 0:
      cout << "case 0\n";
  case1:
  case 1:
      cout << "case 1\n";
      return;
  case 2;
      cout << "case 2\n";
      goto case1;
  default:
      cout << "default: case не найден\n";
      return;
  }
</pre>
<br>При обращении к нему с val==2 выдаст
<pre>
  case 2
  case 1
</pre>
<br>Заметьте, что  метка case  не подходит как метка для употребления в
операторе goto:
<pre>
  goto case 1;        // синтаксическая ошибка
</pre>
<a name=gl3.3.2>
<h3 ALIGN=CENTER>     3.3.2 Goto </h3>
<p>  C++ снабжен имеющим дурную репутацию оператором goto.
<pre>
  goto идентификатор;
  идентификатор : оператор
</pre>
<br>  В общем,  в программировании  высокого уровня он имеет очень мало
применений, но  он может  быть очень  полезен, когда  C++ программа
генерируется программой,  а не  пишется непосредственно  человеком.
Например,  операторы   goto  можно  использовать  в  синтаксическом
анализаторе, порождаемом  генератором синтаксических  анализаторов.
Оператор goto  может быть  также важен  в тех редких случаях, когда
важна наилучшая эффективность, например, во внутреннем цикле какой-
нибудь программы, работающей в реальном времени.
<br>  Одно  из   немногих  разумных  применений  состоит  в  выходе  из
вложенного  цикла   или  переключателя   (break   лишь   прекращает
выполнение  самого   внутреннего  охватывающего   его   цикла   или
переключателя). Например:
<pre>
  for (int i = 0; i
</pre>
<a name=gl3.4>
<h2 ALIGN=CENTER>3.4 Комментарии и Выравнивание </h2>
<p>  Продуманное   использование    комментариев    и    согласованное
использование отступов  может сделать  чтение и понимание программы
намного  более  приятным.  Существует  несколько  различных  стилей
согласованного  использования  отступов.  Автор  не  видит  никаких
серьезных  оснований   предпочесть  один  другому  (хотя  как  и  у
большинства, у  меня есть  свои предпочтения).  Сказанное относится
также и к стилю комментариев.
<br>  Неправильное использование  комментариев может  серьезно повлиять
на удобочитаемость  программы, Компилятор  не  понимает  содержание
комментария, поэтому  он никаким способом не может убедиться в том,
что комментарий
<br>  [1] осмыслен;
<br>  [2] описывает программу; и
<br>  [3] не устарел.
<br>  Непонятные,  двусмысленные   и  просто   неправильные  комментарии
содержатся в  большинстве программ.  Плохой комментарий  может быть
хуже, чем никакой.
<br>  Если что-то можно сформулировать средствами самого языка, следует
это сделать,  а не  просто отметить в комментарии. Данное замечание
относится к комментариям вроде:
<pre>
  // переменная "v" должна быть инициализирована.
  // переменная "v" должна использоваться только функцией "f()".
  // вызвать функцию init() перед вызовом
  // любой другой функции в этом файле.
  // вызовите функцию очистки "cleanup()" в конце вашей
  программы.
  // не используйте функцию "wierd()".
  // функция "f()" получает два параметра.
</pre>
<br>При правильном  использовании C++  подобные комментарии как правило
становятся ненужными. Чтобы предыдущие комментарии стали излишними,
можно,  например,   использовать  правила   компоновки  (<a HREF=GL4.HTM#gl4.2>#4.2 </a>)  и
видимость,  инициализацию   и  правила  очистки  для  классов (см. <a HREF=GL5_2.HTM#gl5_2.5.2>
#5.5.2</a>).
<br>  Если  что-то  было  ясно  сформулировано  на  языке,  второй  раз
упоминать это в комментарии не следует. Например:
<pre>
  a = b+c;    // a становится b+c
  count++;    // увеличить счетчик
</pre>
<br>Такие комментарии  хуже чем  просто излишни,  они увеличивают объем
текса, который  надо прочитать,  они часто  затуманивают  структуру
программы, и они могут быть неправильными.
<br>  Автор предпочитает:
<br> [1] Комментарий для каждого исходного файла, сообщающий, для чего
     в целом  предназначены находящиеся  в нем  комментарии, дающий
     ссылки на  справочники и  руководства, общие  рекомендации  по
     использованию и т.д.;
<br> [2] Комментарий  для  каждой  нетривиальной  функции,  в  котором
     сформулировано ее  назначение, используемый  алгоритм (если он
     неочевиден)  и,   быть  может,  что-то  о  принимаемых  в  ней
     предположениях относительно среды выполнения;
<br> [3] Небольшое число  комментариев в  тех  местах,  где  программа
     неочевидна и/или непереносима; и
<br> [4] Очень мало что еще.
<br>  Например:
<pre>
  // tbl.c: Реализация таблицы имен
  /*
      Гауссовское исключение с частичным
      См. Ralston: "A first course ..." стр. 411.
  */
  // swap() предполагает размещение стека AT&T sB20.
  /**************************************
      Copyright (c) 1984 AT&T, Inc.
      All rights reserved
  ****************************************/
</pre>
<br>  Удачно подобранные и хорошо написанные комментарии - существенная
часть программы. Написание хороших комментариев может быть столь же
сложным, сколь и написание самой программы.
<br>  Заметьте также,  что если  в функции  используются  исключительно
комментарии //,  то любую часть этой функции можно закомментировать
с помощью комментариев /* */, и наоборот.
<a name=gl3.5>
<h2 ALIGN=CENTER>     3.5 Упражнения </h2>
<ol>
<LI> (*1) Перепишите  следующий оператор  for в виде эквивалентного
     оператора while:
<pre>
       for (i=0; im
       *p.m
       *a[i]
</pre>
<li value=7> (*2)  Напишите функции:  strlen(),  которая  возвращает  длину
     строки, strcpy(),  которая копирует  одну строку  в другую,  и
     strcmp(), которая  сравнивает две  строки. Разберитесь,  какие
     должны быть  типы параметров  и типы  возвращаемых значений, а
     потом сравните  их со стандартными версиями, которые описаны в
      и в вашем руководстве.
<li> (*1) Посмотрите, как ваш компилятор реагирует на ошибки:
<pre>
       a := b+1;
       if (a = 3) // ...
       if (a&077 == 0) // ...
</pre>
<br>     Придумайте ошибки попроще, и посмотрите, как компилятор на них
     реагирует.
 <LI> (*2)  Напишите   функцию  cat(),   получающую  два   строковых
     параметра   и    возвращающую   строку,    которая    является
     конкатенацией параметров.  Используйте new, чтобы найти память
     для  результата.  Напишите  функцию  rev(),  которая  получает
     строку и  переставляет в  ней символы  в обратном  порядке. То
     есть,  после  вызова  rev(p)  последний  символ  p  становится
     первым.
 <LI> (*2) Что делает следующая программа?
<pre>
       void send(register* to, register* from, register count)
       // Полезные комментарии несомненно уничтожены.
       {
           register n=(count+7)/8;
           switch (count%8) {
               case 0: do {    *to++ = *from++;
               case 7: do {    *to++ = *from++;
               case 6: do {    *to++ = *from++;
               case 5: do {    *to++ = *from++;
               case 4: do {    *to++ = *from++;
               case 3: do {    *to++ = *from++;
               case 2: do {    *to++ = *from++;
               case 1: do {    *to++ = *from++;
                   while (--n>0);
           }
       }
</pre>
<br>     Зачем кто-то мог написать нечто похожее?
  <LI> (*2)  Напишите   функцию  atoi(),  которая  получает  строку,
     содержащую  цифры, и возвращает соответствующее int. Например,
     atoi("123") -  это 123. Модифицируйте atoi() так, чтобы помимо
     обычной  десятичной   она  обрабатывала   еще  восьмеричную  и
     шестнадцатиричную записи  C++. Модифицируйте atoi() так, чтобы
     обрабатывать запись  символьной  константы.  Напишите  функцию
     itoa(), которая  строит представление  целого параметра в виде
     строки.
 <LI> (*2) Перепишите  get_token() (<a HREF=#gl3.1.2>#3.1.2</a>),  чтобы она за один раз читала строку  в буфер,  а  затем  составляла  лексемы,  читая
     символы из буфера.
 <LI> (*2)  Добавьте   в  настольный  калькулятор  из <a HREF=#gl3.1> #3.1</a>  такие
     функции, как  sqrt(), log() и sin(). Подсказка: предопределите
     имена и  вызывайте функции  с помощью  вектора  указателей  на
     функции. Не забывайте проверять параметры в вызове функции.
 <LI> (*3)  Дайте пользователю  возможность  определять  функции  в
     настольном калькуляторе.  Подсказка: определяйте  функции  как
     последовательность  действий,   прямо  так,   как  их   набрал
     пользователь. Такую  последовательность можно  хранить или как
     символьную строку,  или как  список лексем. После этого, когда
     функция вызывается, читайте и выполняйте эти действия. Если вы
     хотите, чтобы  пользовательская функция получала параметры, вы
     должны придумать форму записи этого.
 <LI> (*1.5) Преобразуйте  настольный калькулятор так, чтобы вместо
     статических    переменных     name_string    и    number_value
     использовалась структура символа symbol:
<pre>
       struct symbol {
           token_value tok;
           union {
               double number_value;
               char* name_string;
           };
       };
</pre>
 <LI> (*2.5) Напишите программу, которая выбрасывает комментарии из
     C++ программы.  То есть,  читает из  cin, удаляет  // и  /* */
     комментарии и пишет результат в cout. Не заботьтесь о приятном
    виде выходного текста (это могло бы быть другим, более сложным
     упражнением).  Не   беспокойтесь  о   правильности   программ.
     Остерегайтесь //  и /*  и  */  внутри  комментариев,  строк  и
     символьных констант.
<LI> (*2) Посмотрите  какие-нибудь программы, чтобы понять принцип
     различных  стилей   комментирования  и  выравнивания,  которые
     используются на практике.
<p>
<small>
<a name=*1>
<br>*<sup>1</sup> Нам  неизвестен русскоязычный термин, эквивалентный английскому
indentation. Иногда это называется отступами. (прим. перев.)
<a name=*2>
<br> *<sup>2</sup> игра слов: "for" - "forever" (навсегда). (прим. перев.)
<a name=*3>
<br> * <sup>3</sup>В  языке немного  лучше этого с этими исключениями тоже надо бы
справляться. (прим. автора)
<a name=*4>
<br>  * <sup>4</sup>знака этой операции. (прим. перев.)
<a name=*5>
<br>* <sup>5</sup>Следовало  бы переводить  как "инкремент" и "декремент", однако
мы следовали  терминологии, принятой  в переводной литературе по C,
поскольку эти операции унаследованы от C. (прим. перев.)
</small>
<p> <center> 
<font size="-1">
[<a href="GL2.HTM">Назад</a>]
[<a href="AGLAV.HTM">Содержание</a>]
[<a href="GL4.HTM">Вперед</a>]
</font>
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
