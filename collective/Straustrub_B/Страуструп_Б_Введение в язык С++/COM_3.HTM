<html><head>
<title>Создание контроллеров автоматизации с помощью  C++Builder</title>
		    <style type="text/css">
TH.arial { font-family: Arial, Serif;}
P.topic { font-family: sans-serif;}
A.plain { text-decoration: none;}
A.topic01 { color: #006890;
font-family: sans-serif;
text-decoration: none;}
A.topic02 { color: #099771;
font-family: sans-serif;
text-decoration: none;}
A.topic03 { color: #719709;
font-family: sans-serif;
text-decoration: none;}
A.topic04 { color: #98650A;
font-family: sans-serif;
text-decoration: none;}
A.topic05 { color: #98340A;
font-family: sans-serif;
text-decoration: none;}
A.topic06 { color: #099607;
font-family: sans-serif;
text-decoration: none;}
A.topic07 { color: #9E1215;
font-family: sans-serif;
text-decoration: none;}
A.topic08 { color: #970941;
font-family: sans-serif;
text-decoration: none;}
A.topic09 { color: #950995;
font-family: sans-serif;
text-decoration: none;}
A.topic010 { color: #390A98;
font-family: sans-serif;
text-decoration: none;}
H1 { font-family: sans-serif;}
H2 { font-family: sans-serif;}
H3 { font-family: sans-serif;}
H4 { font-family: sans-serif;}
H5 { font-family: sans-serif;}
H6 { font-family: sans-serif;}
</style>
</head>
<body bgcolor="#FFFFFF" link="#006890" vlink="#003860" alink="#800000" text="#000000">
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/HEADER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<img src="../../PICTURES/MENU/LOGO.GIF" width=157 height=53 border=0 alt="Server for Information Technologies">
</td><td align="right">
<font size="-2">Сервер поддерживается<br><a class="plain" href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>(095) 932-9212, 932-9213, 939-0783<br>E-mail: <a class=noneline href="mailto:info@citmgu.ru?Subject='From page topic CIT FORUM local copy'">info@citforum.ru</a></font>
</td></tr>
</table>
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="left">
<font size="-1">Сервер содержит море(!) аналитической информации</font>
</td><td align="right">
<font size="-1">CIT Forum CD-ROM</font>
</td></tr>
</table>
</td></tr>
</table>
<p>&nbsp;
<center>
<h3>Создание контроллеров автоматизации с помощью  C++Builder</h3>
<p>Наталия Елманова
</center>
<ul>
<a href=#1>Тестирование сервера автоматизации</a><br>
<ul>
<a href=#11>Создание контроллера</a><br>
<a href=#12>Некоторые комментарии</a>
</ul>
<a href=#2>Создание контроллеров для произвольных серверов автоматизации </a><br>
<ul>
<a href=#21>Коллекции объектов внутри серверов автоматизации</a><br>
<a href=#22>Использование информации из библиотек типов</a>
</ul>
</ul>
<a name=1></a>
<h4>Тестирование сервера автоматизации</h4>
<p align=justify>В предыдущей статье данного цикла мы рассмотрели создание настольного приложения, являющегося сервером автоматизации. Теперь, основываясь на информации о методах  класса его объекта  автоматизации, содержащейся в библиотеке типов, создадим приложение, управляющее этим сервером. Такие приложения называются контроллерами автоматизации.
<a name=11></a>
<h4><i>Создание контроллера</i></h4>
<p align=justify>На главной форме будущего приложения-контроллера  разместим компоненты TEdit, TCheckBox, TOpenDialog, TSaveDialog, а также  десять кнопок.
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_1.GIF" width=250 height=317 border=0 alt="Главная форма контроллера автоматизации">
<p><i>Рис. 1. Главная форма контроллера автоматизации</i>
</center>
<p align=justify>Создадим обработчики событий, связанные с нажатием на кнопки (при этом следует сослаться на h-файл модуля ComObj):
<pre>
//---------------------------------------------------------------------------
#include &lt;vcl.h&gt;
#pragma hdrstop
#include &lt;ComObj.hpp&gt;
#include "autocon.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm2 *Form2;
Variant Serv;
//---------------------------------------------------------------------------
__fastcall TForm2::TForm2(TComponent* Owner)
    : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button3Click(TObject *Sender)
{
  Serv=CreateOleObject("Project1.MyAuto3");
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button1Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) 
Edit1-&gt;Text=IntToStr(Serv.OlePropertyGet("Width"));
// имеет смысл проверить, что именно лежит в вариантной переменной…
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button2Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) Serv.OlePropertySet("Width",StrToInt(Edit1-&gt;Text));
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button12Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) 
CheckBox1-&gt;Checked=Serv.OlePropertyGet("Visible");
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button13Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) Serv.OlePropertySet("Visible",CheckBox1-&gt;Checked);
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button11Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) Serv=Unassigned;
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button5Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch)
{if (OpenDialog1-&gt;Execute())
Serv.OleProcedure("OpenFile",OpenDialog1-&gt;FileName);}
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button6Click(TObject *Sender)
{
 if (VarType(Serv)==varDispatch)
 {  if (SaveDialog1-&gt;Execute())
 Serv.OleProcedure("SaveFile",SaveDialog1-&gt;FileName);}
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button7Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch) Serv.OleProcedure("NewFile");
}
//---------------------------------------------------------------------------
void __fastcall TForm2::Button4Click(TObject *Sender)
{
if (VarType(Serv)==varDispatch)
 Serv.OleProcedure("AddLine",Edit1-&gt;Text);
}
//---------------------------------------------------------------------------
</pre>
<a name=12></a>
<h4><i>Некоторые комментарии</i></h4>
<p align=justify>Теперь настало время пояснить, что именно делает приведенный выше код. 
<p align=justify>Для управления сервером автоматизации мы создали переменную типа Variant (в C++Builder для этой цели имеется соответствующий класс) и вызвали функцию CreateOleObject, содержащуюся в модуле ComObj библиотеки VCL.
<p align=justify>При выполнении функции  CreateOleObject произойдет следующее. Эта функция, вызвав несколько функций Windows  API, создаст экземпляр COM-объекта IDispatch и вернет его внутри вариантной переменной. Этот объект, в свою очередь, содержит интерфейс объекта (в данном случае нашего сервера автоматизации), методы которого мы хотим вызывать из приложения. Если исследовать реализацию функции CreateOleObject в исходном тексте модуля ComObj, можно обнаружить,  что она, в свою очередь, вызывает функцию Windows  API CoCreateInstance, являющуюся частью спецификации COM, назначение которой - создать объект из исполняемого файла или DLL.Переменная типа Variant может содержать разнообразные данные (строку, число и др., в том числе и интерфейс COM-объекта). 
<p align=justify>Отметим, что, в отличие от Visual Basic или Delphi, C++Builder не позволяет обращаться к методам и свойствам вариантных переменных, существование которых заранее неизвестно. Поэтому  допустимый в Delphi код вида
<pre>
if VarType(Serv)=varDispatch then Serv.Width:=StrToInt(Edit1.Text);
</pre>
<p align=justify>не имеет аналога в C++Builder. Дело в том, что при создании контроллеров с помощью Delphi в случае объектов типа Variant, в отличие от объектов другого типа, например, TForm, компилятор не проверяет, имеется ли в действительности такое свойство (в данном случае Width) у данного объекта. На этапе выполнения  такого кода происходит вызов функций Windows API, в результате работы  которых меняется свойство Width объекта, содержащегося   не в адресном проcтранстве созданного контроллера, а в адресном пространстве Excel.
<p align=justify>В С++Builder достичь такого же результата можно с помощью следующего кода:
<pre>
if (VarType(Serv)==varDispatch) Serv.OlePropertySet("Width",StrToInt(Edit1-&gt;Text));
</pre>
<p align=justify>В этом случае на этапе выполнения производится вызов тех же самых функций Windows API, что и в предыдущем случае. OlePropertySet представляет собой оболочку для метода вариантной переменной Exec() (наряду с OlePropertyGet, OleProcedure и OleFunction, позволяющими получать значения свойств объектов автоматизации и выполнять их методы). Отметим, что в Delphi также можно использовать вызовы OlePropertySet, OlePropertyGet, OleProcedure, OleFunction.
<p align=justify>После запуска контроллера при нажатии кнопки Connect запускается сервер. При нажатии кнопки Disconnect он выгружается. При нажатии кнопок New File, Open File и Save File происходит очистка окна редактирования, загрузка текста в окно редактирования сервера из файла, сохранение текста в файле.  Кнопка Get Visible показывает и скрывает окно сервера в зависимости от наличия отметки возле надписи Visible, при этом в невидимом состоянии сервер продолжает выполнять свои функции.  Нажатие кнопки Set Visible приводит отметку возле надписи Visible в соответствие значению свойства Visible сервера.  Нажатие кнопки Get Width приводит к тому, что в строке редактирования в верхней части окна контроллера отображается ширина  окна сервера в пикселах. Если ввести в строку редактирования другое число и нажать кнопку Set Width, ширина окна сервера станет равной введенному числу пикселов. Нажатие кнопки Add String приводит к тому, что в редактируемый текст добавляется строка, находящаяся в этот момент в поле редактирования.
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_2.GIF" width=500 height=331 border=0 alt="Контроллер и сервер автоматизации, запущенные одновременно">
<p><i>Рис. 2. Контроллер и сервер автоматизации, запущенные одновременно</i>
</center>
<p align=justify>Хотелось бы обратить внимание на то, что, хотя мы и смогли протестировать свойства и методы сервера автоматизации с помощью созданного контроллера,  у нас еще не было возможности произвести отладку части кода, связанного с автоматизацией. Естественно, если клиент запускается под управлением  среды разработки  C++Builder, использовать тот же самый экземпляр среды разработки для отладки сервера невозможно. Поэтому следует открыть проект сервера в отдельном экземпляре среды разработки и запустить его на выполнение. Если после этого запустить приложение-контроллер (неважно, под управлением другого экземпляра среды разработки или просто средствами операционной системы) и нажать кнопку Connect, контроллер соединится с уже запущенным  экземпляром сервера.  Если в исходном тексте сервера отмечены точки останова, при их достижении выполнение кода сервера прекращается, и управление передается среде разработки.
<p align=justify>Отметим один очевидный факт: COM-сервер и COM-клиент могут быть написаны с использованием любых средств разработки, поддерживающих COM-технологию. Поэтому в принципе не возбраняется написать сервер автоматизации с помощью. Delphi, а контроллер - с помощью C++Builder (или наоборот).
<a name=2></a>
<h4>Создание контроллеров для произвольных серверов автоматизации </h4>
<p align=justify>Как было сказано в предыдущей статье, наличие тех или иных возможностей управления произвольным сервером зависит от того, какие объекты, свойства и методы сервера предоставлены разработчиками сервера  для автоматизации с помощью внешних приложений. Каким образом можно получить информацию о них? 
<p align=justify>Обычно такие сведения содержатся в документации или файлах справочной системы, поставляемых с данным сервером, как, например, это сделано в MS Office или Seagate Crystal Reports Professional. Но в принципе такую информацию можно получить и из библиотеки типов. 
<p align=justify>В качестве примера рассмотрим использование информации из библиотеки типов MS Excel как одного из наиболее часто используемых серверов автоматизации в практике отечественных разработчиков. Надо заметить, что практически все, что может сделать пользователь, работая с этим приложением, равно как и с другими приложениями MS Office, доступно для автоматизации.
<p align=justify>Как и в предыдущем случае, для управления сервером автоматизации следует создать переменную типа Variant (в C++Builder для этой цели имеется соответствующий класс) и вызвать функцию CreateOleObject:
<pre>
Variant XL;
……
XL=CreateOleObject("Excel.Application.8");
</pre>
<p align=justify>В качестве параметра функции CreateOleObject передается имя объекта, который мы хотим создать. Найти его можно  в реестре Windows:
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_3.GIF" width=564 height=453 border=0 alt="Запись в реестре, соответствующая выбранному серверу">
<p><i>Рис. 3. Запись в реестре, соответствующая выбранному серверу.</i>
</center>
<a name=21></a>
<h4><i>Коллекции объектов внутри серверов автоматизации. </i></h4>
<p align=justify>Внутри некоторых OLE-серверов (в частности, приложений MS Office) существует иерархия вложенных объектов примерно следующего вида:
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_4.GIF" width=344 height=226 border=0 alt="Примерная иерархия  вложенных объектов OLE-сервера">
<p><i>Рис. 4. Примерная иерархия  вложенных объектов OLE-сервера.</i>
</center>
<p align=justify>Свойствами  объектов Excel  могут являться так называемые коллекции объектов. Например, коллекция Workbooks является свойством объекта Excel.Application, при этом она содержит набор вложенных объектов - рабочих книг Excel, а те, в свою очередь, обладают свойством Worksheets, представляющим собой коллекцию рабочих листов, каждый из которых обладает свойством Cells, являющимся коллекцией ячеек.  Аналогично, коллекция Charts также является свойством рабочей книги. Аналогично, внутри свойствами объектов Word могут быть коллекции Paragraphs, Words, Tables. 
<p align=justify>В С++Builder обращение к члену коллекции производится следующим образом:
<p>Variant MyWorkbook=XL.OlePropertyGet("WorkBooks").OlePropertyGet("Item",1);
<p align=justify>Рассмотрим пример, использующий такие коллекции. Пусть при нажатии на кнопку главной формы приложения-клиента будут выполнены следующие действия:
<ul>
<li>создание  в Excel рабочей книги с двумя  страницами и какими-нибудь именами;
<li>заполнение первых 10 ячеек двух первых колонок числами;
<li>вычисление в одиннадцатой ячейке их суммы; 
<li>изменение цвета и начертания шрифта в одной из колонок, а также цвета ячеек;
<li>сохранение полученной рабочей книги в файле.
</ul>
<p align=justify>Код, заставляющий Excel выполнить эти действия, будет выглядеть следующим образом:
<pre>
//---------------------------------------------------------------------------
#include &lt;vcl.h&gt;
#pragma hdrstop
#include &lt;ComObj.hpp&gt;
#include "xlauto2.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
Variant XL,v0,v1,v2;
//Function Item("Item");
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
    : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button1Click(TObject *Sender)
{
XL=CreateOleObject("Excel.Application.8");
XL.OlePropertySet("Visible",true);
v0=XL.OlePropertyGet("Workbooks");
v0.OleProcedure("Add");
v1=v0.OlePropertyGet("Item",1);
v0=v1.OlePropertyGet("Worksheets") ;
v0.OlePropertyGet("Item",1).OlePropertySet("Name","Бухгалтерия желтая");
v0.OlePropertyGet("Item",2).OlePropertySet("Name","Бухгалтерия красная");
for (int j=1;j&lt;3;j++)
{
v1=v0.OlePropertyGet("Item",j);
for (int i=1;i&lt;11;i++)
{
v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,1).OlePropertySet("Value",i);
v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,2).OlePropertySet("Value",i*5);
v2=v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,2);
v2.OlePropertyGet("Font").OlePropertySet("Color",clBlue);
v2.OlePropertyGet("Font").OlePropertySet("Bold",true);
v2.OlePropertyGet("Interior").OlePropertySet("ColorIndex",9-3*j);
}
v1.OlePropertyGet("Cells").OlePropertyGet("Item",11,1).OlePropertySet("Value","=SUM(A1:A10)");
v1.OlePropertyGet("Cells").OlePropertyGet("Item",11,2).OlePropertySet("Value","=SUM(B1:B10)");
}
XL.OlePropertySet("DisplayAlerts",false); //отключить диагностику при закрытии сервера
XL.OlePropertyGet("Workbooks").OlePropertyGet("Item",1).OleProcedure("SaveAs","test.xls");
XL.OleProcedure("Quit");
}
//---------------------------------------------------------------------------
</pre>
<p align=justify>Отметим, что для запуска Excel в фоновом режиме без отображения его окна на экране достаточно  убрать из  кода С++Builder строку:
<pre>
XL.OlePropertySet("Visible",true);
</pre>
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_5.GIF" width=602 height=368 border=0 alt="Результат работы приложения">
<p><i>Рис. 5. Результат работы приложения </i>
</center>
<p align=justify>Следует обратить внимание на то, что вариантная переменная XL  объявлена за пределами процедуры манипуляции OLE-сервером. Это сделано для того, чтобы существование вариантной переменной не ограничивалось данной процедурой.
<a name=22></a>
<h4><i>Использование информации из библиотек типов</i></h4>
<p align=justify>Отметим, что в приведенном выше примере рабочая книга и рабочие листы были созданы с применением параметров,  предлагаемых по умолчанию.  Каким образом можно изменить эти параметры?
<p>Рассмотрим следующий пример кода:
<pre>
XL=CreateOleObject("Excel.Application.8");
XL.OlePropertySet("Visible",true);
v0=XL.OlePropertyGet("Workbooks");
v0.OleProcedure("Add",-4109);
</pre>
<p align=justify>Данный пример заставляет Excel создать пустой лист с диаграммой на основе шаблона, отличного от принятого по умолчанию.
<p align=justify>Откуда в данном случае взялась константа -4109? Каким образом можно узнать, какими еще константами можно пользоваться при автоматизации с использованием данного сервера?
<p align=justify>Ответы на эти вопросы можно получить, открыв библиотеку типов данного сервера. Сделать это можно, выбрав пункт меню File/Open, указав в списке возможных файлов Type Library и выбрав соответствующую библиотеку типов (для Excel это Excel8.olb, для Word - MSWord8.olb). При этом по истечение некоторого времени (эти библиотеки очень велики) будут созданы файлы с описанием всех использованных констант, а также свойств и методов содержащихся в сервере объектов (в данном случае Excel_TLB.cpp и Excel_TLB.h для С++Builder, либо Excel_TLB.pas для Delphi). При создании этих файлов появятся сообщения об ошибках, связанные с тем, что в коде Excel и Word могут использоваться зарезервированные слова Object Pascal или С++. 
<p align=justify>Редактор библиотеки типов при этом представляет все вложенные объекты в виде иерархической структуры, внутри которой можно найти значения необходимых констант. В частности, в разделе шаблонов можно найти список констант, характеризующих различные типы шаблонов листов Excel:
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_6.GIF" width=615 height=332 border=0 alt="Значения констант, описывающих шаблоны  MS Excel 97">
<p><i>Рис. 6. Значения констант, описывающих шаблоны  MS Excel 97</i>
</center>
<p align=justify>Именно там и содержится ссылка на константу xlWBATChart = -4109, соответствующую шаблону диаграммы.
<p align=justify>При необходимости использовать в коде приложения-клиента именованные константы можно сослаться на файл Excel_TLB.h  иди Excel_TLB.pas в тексте модуля приложения.
<p align=justify>Точно так же можно определить, каковы свойства и методы  вложенных объектов данного сервера автоматизации:
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_7.GIF" width=608 height=334 border=0 alt="Свойства и методы коллекции Workbooks">
<p><i>Рис. 7. Свойства и методы коллекции Workbooks</i>
</center>
<p align=justify>Используя сведения о константах, объектах, свойствах и методах OLE-сервера,  можно модифицировать приведенный выше пример. Теперь мы создадим в Excel график на основе данных из рабочих листов, скопируем его в буфер обмена и  перенесем в документ Word (об объектах и константах которого узнаем из  библиотеки типов Word), снабдив график подписью. Соответствующий код  выглядит следующим образом:
<pre>
//---------------------------------------------------------------------------
#include &lt;vcl.h&gt;
#pragma hdrstop
#include "ole2.h"
#include &lt;ComObj.hpp&gt;
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
Variant XL,v0,v1,v2, v22, vrange, WD,a,b,c;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
    : TForm(Owner)
{
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button1Click(TObject *Sender)
{
XL=CreateOleObject("Excel.Application.8");
XL.OlePropertySet("Visible",true);
v0=XL.OlePropertyGet("Workbooks");
v0.OleProcedure("Add");
v1=v0.OlePropertyGet("Item",1);
v0=v1.OlePropertyGet("Worksheets") ;
v22=v1.OlePropertyGet("Charts") ;
v22.OleProcedure("Add");
v0.OlePropertyGet("Item",1).OlePropertySet("Name","Бухгалтерия желтая");
v0.OlePropertyGet("Item",2).OlePropertySet("Name","Бухгалтерия красная");
for (int j=1;j&lt;3;j++)
{
v1=v0.OlePropertyGet("Item",j);
for (int i=1;i&lt;11;i++)
{
v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,1).OlePropertySet("Value",i);
v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,2).OlePropertySet("Value",i*5);
v2=v1.OlePropertyGet("Cells").OlePropertyGet("Item",i,2);
v2.OlePropertyGet("Font").OlePropertySet("Color",clBlue);
v2.OlePropertyGet("Font").OlePropertySet("Bold",true);
v2.OlePropertyGet("Interior").OlePropertySet("ColorIndex",9-3*j);
}
v1.OlePropertyGet("Cells").OlePropertyGet("Item",11,1).OlePropertySet("Value","=SUM(A1:A10)");
v1.OlePropertyGet("Cells").OlePropertyGet("Item",11,2).OlePropertySet("Value","=SUM(B1:B10)");
}
vrange=v0.OlePropertyGet("Item",1).OlePropertyGet("Range","A1:A10");
v1=v22.OlePropertyGet("Item",1);
v2=v1.OlePropertyGet("SeriesCollection");
v2.OleProcedure("Add",vrange);
vrange=v0.OlePropertyGet("Item",1).OlePropertyGet("Range","B1:B10");
v2.OleProcedure("Add",vrange);
v1.OleProcedure("Select");
XL.OlePropertyGet("Selection").OleProcedure("Copy");
WD=CreateOleObject("Word.Application.8");
WD.OlePropertySet("Visible",true);
WD.OlePropertyGet("Documents").OleProcedure("Add");
a=WD.OlePropertyGet("Documents");
b=a.OleFunction("Item",1);
for (int i=1;i&lt;5;i++)
{b.OlePropertyGet("Paragraphs").OleProcedure("Add");};
c=b.OleFunction("Range",1,2);
c.OleProcedure("Paste");
 c=b.OleFunction("Range",3,3);
c.OlePropertySet("Text","График, скопированный из рабочей книги  Excel ");
XL.OlePropertySet("DisplayAlerts",false); //ioee??eou aeaaiinoeeo
XL.OlePropertyGet("Workbooks").OlePropertyGet("Item",1).OleProcedure("SaveAs","test.xls");
XL.OleProcedure("Quit");
WD.OlePropertySet("DisplayAlerts",false); //ioee??eou aeaaiinoeeo
b.OleProcedure("SaveAs","test2.DOC");
WD.OleProcedure("Quit");
}
//---------------------------------------------------------------------------
</pre>
<p>Результаты работы приложения представлены на рис. 8.
<center>
<p><img src="../../PICTURES/IT/COM_3/COM_3_8.GIF" width=553 height=489 border=0 alt="Результат автоматизации создания диаграммы Excel и переноса ее в Word">
<p><i>Рис.8. Результат автоматизации создания диаграммы Excel и переноса ее в Word</i>
</center>
<p align=justify>Итак, создав код, подобный приведенному выше,  мы можем автоматизировать довольно сложный набор рутинных пользовательских операций, что может быть весьма удобно, если  такие операции часто повторяются. При этом создание такого кода, в общем случае, безусловно, требует гораздо меньших усилий, чем  написание отдельного приложения, реализующего какие-то части функциональности Word или Excel. 
<p align=justify>Следующая статья данного цикла будет посвящена использованию OLE-документов в приложениях C++Builder.
<p>Координаты автора:<br>
Центр Информационных Технологий,<br>
Тел. (095)932-92-12, 932-92-13,<br>
<a href=mailto:elmanova@citmgu.ru>elmanova@citmgu.ru</a>,<br>
<a href=http://www.citmgu.ru>http://www.citmgu.ru</a>, <br>
<a href=http://www.citforum.ru>http://www.citforum.ru</a>
<p>&nbsp;
<table cellspacing=0 cellpadding=0 border=0 background="../../PICTURES/MENU/FOOTER0.JPG" width="100%">
<tr><td align="center">
<table cellspacing=0 cellpadding=4 border=0 width="100%" background="">
<tr><td align="right" valign="top" width="33%">
<font size="-2">Comments: <a class="plain" href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM local copy'">info@citmgu.ru</a><br>
Designed by <a class="plain" href="mailto:andrey@novikov.com">Andrey Novikov</a><br>
Copyright &copy; <a class="plain" href="http://www.citmgu.ru/">CIT</a></font>
</td></tr>
</table>
</td></tr>
</table></body></html>
